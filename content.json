{"posts":[{"title":"你好，世界","text":"欢迎来到 Hexo！这是你的第一篇文章。更多信息请查看 文档。如果在使用 Hexo 时遇到任何问题，你可以在 故障排除 中找到答案，或者在 GitHub 上向我提问。 快速入门创建新文章1$ hexo new &quot;我的新文章&quot; 更多信息：写作 运行服务器1$ hexo server 更多信息：服务器 生成静态文件1$ hexo generate 更多信息：生成 部署到远程站点1$ hexo deploy 更多信息：部署","link":"/uncategorized/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/"},{"title":"Icarus 用户指南｜Cyberpunk Theme Variant","text":"Icarus 从 3.0.0 版本开始包含一个名为 “赛博朋克” 的新变体。 该主题的灵感来源于 CD PROJEKT RED 开发的电子游戏 《赛博朋克 2077》。 此变体旨在为喜欢暗黑主题博客的用户提供不同的 Icarus 体验。 需要注意的是，它使用了最新的网页样式特性，这些特性在某些旧版浏览器（包括 Internet Explorer 和旧版 Microsoft Edge）中无法正常工作。 要启用赛博朋克主题，请打开 _config.icarus.yml 并进行以下修改： _config.icarus.yml12- variant: default+ variant: cyberpunk 你可能还想更改代码块的高亮主题。 在这种情况下，你可以在 这里 找到一些暗黑系的 highlight.js 主题。 复制文件名（不包含 .css 扩展名），并将其放入 _config.icarus.yml 中的 article.highlight.theme 选项。 例如，如果你想将主题更改为 xt256，请进行以下修改： _config.icarus.yml12345# 文章相关配置article: highlight:- theme: atom-one-light+ theme: xt256 除了调色板之外，Icarus 还使用了两张图像资源，分别放置在顶部导航栏和页面底部页脚，这些资源来自《赛博朋克 2077》官方网站。 如果你希望进一步修改此主题变体，可以查看 &lt;icarus_directory&gt;/source/css/cyberpunk.styl。","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9Ccyberpunk-theme-variant/"},{"title":"Icarus 用户指南｜Hexo 内置标签指南","text":"以下内容取自 Hexo 文档 并略有修订。 标签插件与文章标签不同。它们从 Octopress 移植而来，为你快速添加特定内容到文章中提供了一种实用方法。 块引用非常适合在文章中添加引用内容，可选择性包含作者、来源和标题信息。 别名： quote 123{% blockquote [author[, source]] [link] [source_link_title] %}内容{% endblockquote %} 示例不带参数。普通块引用。 123{% blockquote %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.{% endblockquote %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 引用自书籍 123{% blockquote David Levithan, Wide Awake %}不要只为自己寻求幸福。要为所有人寻求幸福。通过仁慈。通过怜悯。{% endblockquote %} 不要只为自己寻求幸福。要为所有人寻求幸福。通过仁慈。通过怜悯。 David LevithanWide Awake 引用自 Twitter 123{% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %}新功能：DevDocs 现在带有语法高亮功能。http://devdocs.io {% endblockquote %} 新功能：DevDocs 现在带有语法高亮功能。http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用自网页文章 123{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html 欢迎来到 Island Marketing %}每一次互动都弥足珍贵，也是一次愉悦的机会。{% endblockquote %} 每一次互动都弥足珍贵，也是一次愉悦的机会。 Seth Godin欢迎来到 Island Marketing 代码块这是在文章中添加代码片段的实用功能。 别名： code 123{% codeblock [title] [lang:language] [url] [链接文本] [附加选项] %}代码片段{% endcodeblock %} 示例普通代码块 123{% codeblock %} alert('你好，世界！'); {% endcodeblock %} 1alert('你好，世界！'); 指定语言 123{% codeblock lang:objc %}[rectangle setX: 10 y: 10 width: 20 height: 20];{% endcodeblock %} 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 为代码块添加标题 123{% codeblock Array.map %}array.map(callback[, thisArg]) {% endcodeblock %} Array.map1array.map(callback[, thisArg]) 添加标题和 URL 1234{% codeblock _.compact http://underscorejs.org/#compact Underscore.js %}_.compact([0, 1, false, 2, '', 3]); =&gt; [1, 2, 3] {% endcodeblock %} _.compactUnderscore.js12_.compact([0, 1, false, 2, '', 3]); =&gt; [1, 2, 3] 反引号代码块这与使用代码块相同，但使用三个反引号来分隔代码块。 1`` [language] [title] [url] [link text] code snippet `` 拉取引用要在文章中添加拉取引用： 123{% pullquote [class] %}内容{% endpullquote %} iframe嵌入 iframe： 1{% iframe url [宽度] [高度] %} 图片插入指定大小的图片。 1{% img [类名] /path/to/image [宽度] [高度] '&quot;标题文本&quot; &quot;替代文本&quot;' %} 链接插入带有 target=&quot;_blank&quot; 属性的链接。 1{% 链接文本 url [外部] [标题] %} Hexo.io 包含代码插入 source/downloads/code 文件夹中的代码片段。 1{% include_code [标题] [语言：语言] [发件人：行] [收件人：行] 路径/到/文件 %} 示例嵌入 test.js 的全部内容 1{% include_code lang:javascript test.js %} 仅嵌入第 3 行 1{% include_code lang:javascript 从：3 到：3 test.js %} 嵌入第 5 至 8 行 1{% include_code lang:javascript 从：5 到：8 test.js %} 将第 5 行嵌入到文件末尾 1{% include_code lang:javascript 来自:5 test.js %} 嵌入第 1 至 8 行 1{% include_code lang:javascript 到:8 test.js %} 包含文章包含指向其他文章的链接。 12{% post_path 文件名 %} {% post_link 文件名 [标题] [转义] %} 包含资源包含文章资源。 123{% asset_path 文件名 %} {% asset_img [类名] slug [宽度] [高度] [标题文本 [替代文本]] %} {% asset_link 文件名 [标题] [转义] %} 原始内容如果某些内容在文章处理中导致问题，可以使用 raw 标签将其包裹，以避免渲染错误。 123{% raw %}内容{% endraw %} 文章摘要将 &lt;!-- more --&gt; 标签之前的文本用作帖子的摘要。如果在前置事项中指定了 excerpt: 值，则该值优先。 示例: 123Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;!-- more --&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9Chexo-%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE%E6%8C%87%E5%8D%97/"},{"title":"JavaScript 中的引用相等性和值相等性","text":"在 JavaScript 中，理解不同数据类型的比较行为对于编写正确且高效的代码至关重要。本文将探讨 == 运算符如何处理基本类型和引用类型的比较，并通过示例来加深理解。 == 比较运算符== 是 JavaScript 中用于检查两个值是否相等的运算符。它会根据操作数的数据类型执行不同的比较逻辑： 基本类型（如 number, string, boolean）：直接比较它们的值。 引用类型（如 Array, Object, Function 等）：比较的是对象的引用，即它们在内存中的地址。 示例代码分析考虑下面这段代码： 1234567let a = [1, 2, 3];const mySet = new Set([a, 2, 3, 4, 5]);for (let item of mySet) { console.log(item);}console.log(mySet.has([1, 2, 3])); // 返回 false mySet.has([1, 2, 3]) 同样返回 false，因为 has 方法是基于对象引用进行比较的，而新创建的数组 [1, 2, 3] 与 Set 中原有的数组 a 不是指向同一块内存地址。 不同数据类型的比较基本类型对于基本类型，== 比较它们的值： 123console.log(1 == 1); // trueconsole.log('hello' == 'hello'); // trueconsole.log(true == true); // true 引用类型对于引用类型，== 比较的是引用，而不是内容： 1234567let arr1 = [1, 2, 3];let arr2 = [1, 2, 3];console.log(arr1 == arr2); // falselet obj1 = { a: 1 };let obj2 = { a: 1 };console.log(obj1 == obj2); // false 元组（Tuple）JavaScript 使用数组来模拟元组，因此也是基于引用比较： 123let tuple1 = [1, 2, 3];let tuple2 = [1, 2, 3];console.log(tuple1 == tuple2); // false 字典（Dictionary）使用 Object 或 Map 实现的字典同样基于引用比较： 1234567let dict1 = { a: 1, b: 2 };let dict2 = { a: 1, b: 2 };console.log(dict1 == dict2); // falselet map1 = new Map([['a', 1], ['b', 2]]);let map2 = new Map([['a', 1], ['b', 2]]);console.log(map1 == map2); // false 总结 当使用 == 来比较基本类型时，实际上是在比较它们的值。 当使用 == 来比较引用类型时，实际上是在比较它们的引用，而不是它们所包含的内容。 如果需要比较引用类型的值而非引用，可以使用 JSON.stringify() 转换为字符串后再比较，或者实现自定义的深比较函数。","link":"/%E4%BB%A3%E7%A0%81%E5%BF%83%E5%BE%97/javascript-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E6%80%A7%E5%92%8C%E5%80%BC%E7%9B%B8%E7%AD%89%E6%80%A7/"},{"title":"从三数之和看优化算法的探索路线","text":"在算法学习中，我们经常遇到这样的困扰：能看懂别人的代码，但很难独立想出类似的思路。LeetCode 第 15 题“三数之和”就是一个典型例子。它的最优解在结构上看似巧妙，很多人会直接记住代码，但忽略了更重要的——如何从零推导出这样的思路。 本文将以“三数之和”为起点，完整还原从暴力解到最优解的思维过程，并展示一套可迁移的“优化路径”，帮助你建立真正的算法感知能力。 问题描述给定一个整数数组 nums，要求找出所有不重复的三元组 (a, b, c)，使得： 1a + b + c = 0 注意： 三个数不能重复使用同一个下标 结果中不能包含重复的三元组 Step 1：从暴力解出发（时间复杂度 O(n³)）最直接的方式是三重嵌套循环，枚举所有三元组： 123456789for (let i = 0; i &lt; nums.length; i++) { for (let j = i + 1; j &lt; nums.length; j++) { for (let k = j + 1; k &lt; nums.length; k++) { if (nums[i] + nums[j] + nums[k] === 0) { // 收集三元组 } } }} 虽然可以得到正确答案，但时间复杂度为 O(n³)，在实际使用中效率极低。 关键问题：如何减少枚举的次数？有没有可能只枚举部分元素？ Step 2：固定一位，转化为“两数之和”问题（O(n²)）如果我们先固定一个数 a = nums[i]，问题就变成了在剩下的数组中找出两个数 b 和 c，满足： 1b + c = -a 也就是说，“三数之和”变成了“在数组的子区间中找出两个数，其和为一个目标值”的问题，这正是经典的“两数之和”。 这一步是关键的结构性转化，使得时间复杂度从 O(n³) 降为 O(n²)。 Step 3：在子数组中寻找两数之和（哈希表 vs 双指针）常见方法是使用哈希表： 12345678let seen = new Set();for (let j = i + 1; j &lt; nums.length; j++) { let complement = -nums[i] - nums[j]; if (seen.has(complement)) { // 找到一组 } seen.add(nums[j]);} 该方法时间复杂度为 O(n)，加上外层循环总复杂度为 O(n²)。缺点是空间复杂度较高，且处理重复三元组比较麻烦。 更进一步的思考是：如果数组是有序的，是否可以用双指针来优化查找和去重？ Step 4：排序 + 双指针（结构性优化）将数组排序后，我们可以使用双指针从左右两端向中间逼近，寻找两个数的和是否等于目标值 -a。 整体思路如下： 对数组进行排序，时间复杂度 O(n log n) 枚举第一个数 nums[i]，跳过重复值 使用左右指针 left 和 right，在子区间内寻找匹配的两个数 在找到满足条件的三元组后，继续跳过重复值以防止结果重复 代码实现如下： 1234567891011121314151617181920212223nums.sort((a, b) =&gt; a - b);for (let i = 0; i &lt; nums.length - 2; i++) { if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue; let left = i + 1, right = nums.length - 1; while (left &lt; right) { let sum = nums[i] + nums[left] + nums[right]; if (sum === 0) { result.push([nums[i], nums[left], nums[right]]); while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) left++; while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) right--; left++; right--; } else if (sum &lt; 0) { left++; } else { right--; } }} 最终的时间复杂度依然为 O(n²)，但： 空间复杂度仅为 O(1) 去重处理更为自然 结构清晰，逻辑易懂 这就是“三数之和”问题的最优解法。 Step 5：总结优化思路路径我们可以总结如下的优化路径： 123456789Step 1：三重循环暴力解（O(n³)）↓Step 2：固定一位，转为“两数之和 = -a”（O(n²)）↓Step 3：两数之和 → 哈希表 or 双指针↓Step 4：排序后使用双指针 → 实现结构性优化↓Step 5：自然去重、空间最优，得到最终解法（O(n²), O(1)） 从这个过程中可以看出，高效解法并不是突发奇想，而是一步步推导和重构的结果。 进阶思考：两数之和也可以使用双指针实现 O(n)许多人习惯用哈希表解决“两数之和”问题，但如果数组已排序，使用双指针其实更高效、空间更优： 123456789function twoSumSorted(nums, target) { let left = 0, right = nums.length - 1; while (left &lt; right) { let sum = nums[left] + nums[right]; if (sum === target) return [nums[left], nums[right]]; else if (sum &lt; target) left++; else right--; }} 该算法时间复杂度为 O(n)，空间复杂度为 O(1)，结构简洁，效率更高。 当然，对于力扣第一题的两数之和中元素本是无序的情况，如果直接排序会打乱原数组的索引，此时如果一定要使用双指针法，可以使用 const arr = nums.map((val, idx) =&gt; [val, idx]); 给每个值打上原始位置的标签。力扣两数之和如果使用双指针法，由于进行了排序，时间复杂度会变为 O(nLogn)。 哈希法善于快速定位值与索引的关系，适用于对下标敏感、目标值唯一确定的问题，如 Two Sum。 双指针法善于在有序数组中压缩搜索空间，更适合多数值组合的情况，如 Three Sum、Four Sum，尤其适用于需要避免重复组合的场景。 建议的训练方法为了具备独立推导这类解法的能力，建议你在日常刷题中遵循以下步骤： 从暴力法开始写起：先解出正确性，再优化效率。 关注重复计算：寻找是否存在“固定部分”或“重复结构”。 尝试结构性转化：如“固定一位”→“转为子问题”。 构建优化工具箱：熟练使用排序、哈希表、双指针、滑动窗口等常见技巧。 总结推导过程：把一题背后的优化路径复盘成笔记。 附加笔记：关于 sort() 我们需要知道的在 JavaScript 里，sort() 是数组对象的一个内置方法，其主要功能是对数组元素进行排序。基础用法 若不传入参数，sort() 会按照 Unicode 编码的顺序对元素进行排序，排序时会先将元素转换为字符串。 123const fruits = ['apple', 'banana', 'cherry', 'date'];fruits.sort();console.log(fruits); // 输出: ['apple', 'banana', 'cherry', 'date'] 需要注意的是，若直接对数字数组排序，可能会得到不符合预期的结果。 123const numbers = [10, 5, 8, 1, 2];numbers.sort();console.log(numbers); // 输出: [1, 10, 2, 5, 8] 这是因为 sort() 默认将元素转换为字符串后再比较，所以 &quot;10&quot; 会排在 &quot;2&quot; 之前。 自定义排序规则若想实现自定义排序，比如按数字大小排序，就需要给 sort() 传入一个比较函数。该函数要返回一个数值，用于指示两个元素的相对顺序。 比较函数的形式为 function(a, b) {...} ，其返回值规则如下： 若返回值小于 0，则a会排在b前面。 若返回值等于 0，则a和b的相对位置保持不变。 若返回值大于 0，则a会排在b后面。","link":"/%E4%BB%A3%E7%A0%81%E5%BF%83%E5%BE%97/%E4%BB%8E%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E7%9C%8B%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A2%E7%B4%A2%E8%B7%AF%E7%BA%BF/"},{"title":"从 DFS 到动态规划：算法优化思想的演进","text":"在算法设计中，同一个问题往往可以用不同的方法求解。本文将以一个具体的例子，探讨从最基础的深度优先搜索（DFS）到动态规划的演进过程，分析每一步优化背后的思想。 从一个例子开始让我们以经典的”爬楼梯”问题为例：假设你正在爬楼梯，每次可以爬 1 或 2 个台阶，请问爬到第 n 阶有多少种不同的方法？ 方案一：朴素 DFS最直观的解法是使用 DFS，把问题分解为更小的子问题： 1234function climbStairs(n) { if (n &lt;= 1) return 1; return climbStairs(n - 1) + climbStairs(n - 2);} 这种方法的问题在于： 存在大量重复计算 时间复杂度为 O(2^n)，呈指数级增长 当 n 较大时可能导致栈溢出 方案二：记忆化搜索观察发现，DFS 过程中有许多子问题被重复计算。比如计算 f(5) 时，f(3) 会在计算 f(4) 和 f(5) 时各被计算一次。通过存储已计算的结果，我们可以避免重复计算： 12345678function climbStairs(n, memo = new Map()) { if (n &lt;= 1) return 1; if (memo.has(n)) return memo.get(n); const result = climbStairs(n - 1, memo) + climbStairs(n - 2, memo); memo.set(n, result); return result;} 优化效果： 时间复杂度降至 O(n) 空间复杂度为 O(n) 保持了递归的清晰思路 方案三：动态规划记忆化搜索本质上是”自顶向下”的解法。既然我们已经找到了子问题之间的关系，何不直接”自底向上”地构建解答？ 12345678910function climbStairs(n) { const dp = new Array(n + 1); dp[0] = dp[1] = 1; for (let i = 2; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n];} 这种方法的优势： 避免了递归调用的开销 代码更简洁，执行更高效 便于理解和维护 方案四：空间优化观察发现，在计算过程中，我们每次只需要用到最近的两个状态。因此可以只用两个变量来存储状态，进一步优化空间复杂度： 12345678910function climbStairs(n) { if (n &lt;= 1) return 1; let prev = 1, curr = 1; for (let i = 2; i &lt;= n; i++) { [prev, curr] = [curr, prev + curr]; } return curr;} 优化思想分析这个演进过程展示了几个重要的算法设计思想： 问题分解： DFS 通过递归将问题分解为规模更小的子问题 找到问题的最优子结构是后续优化的基础 避免重复： 记忆化搜索通过存储中间结果避免重复计算 这种”以空间换时间”的思想是算法优化的常用手段 方向转换： 从”自顶向下”到”自底向上”的转变 递推代替递归，往往能带来性能提升 状态压缩： 分析状态转移过程，只保留必要的状态 这种思想在处理大规模数据时特别重要 总结与思考从 DFS 到动态规划的演进，展示了算法优化的一般过程： 先写出最直观的解法 发现并消除重复计算 寻找更优的求解方向 优化空间使用 这个过程不仅适用于本例，也是解决其他算法问题的重要思路。关键是要善于发现问题中的重复计算，并找到优化的突破口。","link":"/%E4%BB%A3%E7%A0%81%E5%BF%83%E5%BE%97/%E4%BB%8E-dfs-%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%80%9D%E6%83%B3%E7%9A%84%E6%BC%94%E8%BF%9B/"},{"title":"代码随想录算法训练营第11天｜栈与队列Part02","text":"记录题目： 滑动窗口最大值 前 K 个高频元素 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到最右侧。你只能看到滑动窗口内的 k 个数字，窗口每次只向右移动一位。 请返回滑动窗口中的最大值序列。 LeetCode239. 滑动窗口最大值 单调队列类 MonoQueue 实现： 1234567891011121314151617181920212223242526class MonoQueue { constructor() { this.queue = []; // 储存元素的队列，维护一个单调递减序列（队头最大） } // 将新元素加入队尾，并维护队列的单调性 push(value) { // 若新元素大于当前队尾元素，则不断弹出队尾，保持队列递减 while (this.queue.length &amp;&amp; value &gt; this.queue[this.queue.length - 1]) { this.queue.pop(); } this.queue.push(value); } // 如果当前离开窗口的元素恰好是队头最大值，则将其移除 pop(value) { if (this.queue.length &amp;&amp; this.queue[0] === value) { this.queue.shift(); } } // 获取当前窗口内的最大值 getMax() { return this.queue[0]; }} 给你一个整数数组 nums 和一个整数 k，请你返回其中出现频率最高的 k 个元素。返回结果可以按 任意顺序。 LeetCode347. 前 K 个高频元素 这道题目主要涉及到如下三部分： 要统计元素出现频率 对频率排序 找出前K个高频元素 统计频率最合适的方式是使用哈希表，其构造过程时间复杂度为 O(n)。在此基础上，如果使用快速排序对所有元素按频率排序，时间复杂度为 O(nlogn)，但这会引入额外“副作用”：即我们仅需要前 k 个高频元素，却对所有元素都进行了排序，这实际上是对问题规模的不必要扩张。 从一个可类比的角度出发，我称之为： 复杂度守恒定律 问题规模 ≈ 时间复杂度贡献 + 空间复杂度贡献 且两者应与实际需求成比例。 在这个问题中，如果我们避免对前 k 个之外的元素频率排序，时间复杂度理应降低。由于空间开销主要集中在哈希表上，若空间未变，那么时间复杂度降低的空间确实存在。 这启发我们：应该存在一种算法，能在不排序所有元素的前提下，仅维护出前 k 个频率最高的元素。堆（优先队列）正好满足这个需求： 使用最小堆维护一个大小为 k 的窗口； 对所有元素频率依次入堆，维护堆中始终为当前频率最高的 k 个元素； 最终堆中的元素即为所求。 该方法时间复杂度为 O(nlogk)，其中 n 为不同元素的个数，k 为所需高频元素数量。当 k = n 时，退化为堆排序，其复杂度为 O(n \\log n)，与快速排序一致。 12345678910111213141516171819202122/** * @param {number[]} nums * @param {number} k * @return {number[]} */var topKFrequent = function (nums, k) { const map = new Map(); const res = []; //使用 map 统计元素出现频率 for (const num of nums) { map.set(num, (map.get(num) || 0) + 1); } //创建小顶堆 const heap = new PriorityQueue((a, b) =&gt; a.value - b.value) for (const [key, value] of map) { heap.enqueue({ key, value }); if (heap.size() &gt; k) heap.dequeue(); } //处理输出 while (heap.size()) res.push(heap.dequeue().key); return res;};","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC11%E5%A4%A9%EF%BD%9C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97part02/"},{"title":"代码随想录算法训练营第13天｜二叉树Part01","text":"本文主要介绍了二叉树的存储和遍历方法。 二叉树储存方法二叉树可以链式存储，也可以顺序存储。 二叉树遍历方法1.深度优先遍历 DFS 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 2.广度优先遍历 BFS 层次遍历（迭代法） 前序遍历 中序遍历 后序遍历 层序遍历 12345var preorderTraversal = function(root) { return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : [];}; 12345678910111213141516var preorderTraversal = function(root, res = []) { const stack = []; if (root) stack.push(root); while(stack.length) { const node = stack.pop(); if(!node) { res.push(stack.pop().val); continue; } if (node.right) stack.push(node.right); if (node.left) stack.push(node.left); stack.push(node); stack.push(null); }; return res;}; 12345var inorderTraversal = function(root) { return root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];}; 12345678910111213141516var inorderTraversal = function(root, res = []) { const stack = []; if (root) stack.push(root); while(stack.length) { const node = stack.pop(); if(!node) { res.push(stack.pop().val); continue; } if (node.right) stack.push(node.right); stack.push(node); stack.push(null); if (node.left) stack.push(node.left); }; return res;}; 12345var postorderTraversal = function(root) { return root ? [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val] : [];}; 12345678910111213141516var postorderTraversal = function(root, res = []) { const stack = []; if (root) stack.push(root); while(stack.length) { const node = stack.pop(); if(!node) { res.push(stack.pop().val); continue; } stack.push(node); stack.push(null); if (node.right) stack.push(node.right); if (node.left) stack.push(node.left); }; return res;}; 123456789101112131415161718192021222324var levelOrder = function(root) { //二叉树的层序遍历 let res = [], queue = []; queue.push(root); if(root === null) { return res; } while(queue.length !== 0) { // 记录当前层级节点数 let length = queue.length; //存放每一层的节点 let curLevel = []; for(let i = 0;i &lt; length; i++) { let node = queue.shift(); curLevel.push(node.val); // 存放当前层下一层的节点 node.left &amp;&amp; queue.push(node.left); node.right &amp;&amp; queue.push(node.right); } //把每一层的结果放到结果数组 res.push(curLevel); } return res;}; 常见用途 遍历类型 常见用途 前序遍历 DFS 构造路径、序列化树、翻转、复制树等 中序遍历 DFS 二叉搜索树（BST）相关操作，如验证、有序性恢复等 后序遍历 DFS 删除树、计算深度、后置汇总型操作等 层序遍历 BFS 按层输出、最短路径、分层汇总、节点可见性等问题 特性对比 对比维度 深度优先遍历（DFS） 广度优先遍历（BFS） 遍历顺序控制 顺序灵活：可先左后右，也可先右后左 顺序固定：逐层从左到右，从上到下 实现方式 递归（利用系统调用栈）或显式使用栈模拟 显式使用队列迭代实现 路径构造 可通过递归参数或栈自动记录路径，天然支持根到叶路径 需显式记录路径（通常需额外数组或字符串同步） 信息传递能力 子调用可通过参数或返回值传递信息，便于处理父子关联逻辑 当前仅处理一个节点，无法感知同层其他节点信息 适合的题型 结构型问题：如树高计算、路径和、镜像翻转、构造路径、子结构判断等 层级型问题：如每层最大值、最短路径、层序遍历、右视图等 可否中途返回 支持灵活剪枝（如：找到目标路径即返回） 可中途 break，但路径信息管理较复杂 显式结构需求 递归时依赖调用栈即可迭代需手动维护栈结构 必须使用显式队列维护节点状态","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC13%E5%A4%A9%EF%BD%9C%E4%BA%8C%E5%8F%89%E6%A0%91part01/"},{"title":"代码随想录算法训练营第10天｜栈与队列Part01","text":"记录题目： 用栈实现队列 用队列实现栈 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top、peek/pop from top、size 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 LeetCode232. 用栈实现队列 以本题为例，一开始我采用的思路是：将 OUT 栈全部弹出，将元素 x 压入 IN 栈，再将 IN 栈全部倒入 OUT 栈，以此维持 OUT 栈的出栈顺序与队列一致。 但题解中提供了更简洁高效的做法：IN 栈专用于入队，OUT 栈专用于出队，仅在 OUT 栈为空时才将 IN 中的所有元素一次性转入 OUT。这一设计更清晰，也避免了不必要的重复操作。 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false。 注意： 你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。你可以使用 list（列表）或者 deque（双端队列）来模拟一个队列，只要是标准的队列操作即可。 LeetCode225. 用队列实现栈 很多时候我们能写出题解，是因为已知某种方法可行；但实际困难往往在于：能否通过分析自主推导出这条路径。这才是算法训练的关键。 近期我意识到：对于完全陌生的题，即使花费大量时间也不一定能写出正确解法；而对于曾接触过的题目，即便间隔一段时间，也能较为轻松地重现解法。因此在后续训练中，要特别关注那些掌握尚不扎实的题目，及时复习与反思，避免仅凭模糊印象通过。 栈与递归在某种程度上是可以相互转换的 从本质上看，递归调用依赖的是函数调用栈，而显式使用栈结构，可以在某些场景下模拟递归过程，达到相同的逻辑效果。两者的核心相通之处在于：都通过“后进先出”的结构来保存中间状态，从而支持问题的分治与回溯。 在实际编程中，这种转换具有很强的实用意义。例如： 遇到递归栈层数过深、存在栈溢出风险时，可以用显式栈改写为迭代； 某些 DFS/BFS 场景下，可以根据需要在递归与栈之间灵活切换，优化控制流程； 使用显式栈更容易在遍历过程中加入剪枝、记录路径等细节逻辑，而递归可能更简洁直观。 因此，理解这一转换关系有助于我们更灵活地设计算法结构，既能写出清晰的递归代码，也能在需要时落地为高效安全的非递归实现。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC10%E5%A4%A9%EF%BD%9C%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97part01/"},{"title":"代码随想录算法训练营第15天｜二叉树Part03","text":"记录题目： 路径总和 路径总和 II 二叉树的最近公共祖先 如何判断递归函数是否需要返回值？ 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值， 因为遇到符合条件的路径了就要及时返回，通常可以用布尔类型表示。 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 路径总和 路径总和 II 二叉树的最近公共祖先 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 LeetCode112. 路径总和 返回值为布尔类型： 12345678910111213/** * @param {TreeNode} root * @param {number} targetSum * @return {boolean} */let hasPathSum = function (root, targetSum) { if (!root) return false; // 当前节点是叶子节点，检查路径和是否正好为 targetSum if (!root.left &amp;&amp; !root.right &amp;&amp; root.val === targetSum) return true; // 向左右子树递归查找 return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);}; 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 LeetCode113. 路径总和 II 无返回值： 12345678910111213141516171819var pathsum = function(root, targetsum) { let respath = [], curpath = []; const traveltree = function(node, count) { curpath.push(node.val); count -= node.val; if(node.left === null &amp;&amp; node.right === null &amp;&amp; count === 0) { respath.push([...curpath]); } node.left &amp;&amp; traveltree(node.left, count); node.right &amp;&amp; traveltree(node.right, count); let cur = curpath.pop(); count -= cur; } if(root === null) { return respath; } travelTree(root, targetSum); return resPath;}; 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” LeetCode236. 二叉树的最近公共祖先 返回值为目标节点： 12345678910var lowestCommonAncestor = function(root, p, q) { const dfs = function(node) { if (node === null || node === p || node === q) return node; const left = dfs(node.left); const right = dfs(node.right); if (left &amp;&amp; right) return node; return left || right; }; return dfs(root);}; 思路分析该算法使用了后序遍历（即“左右中”的遍历顺序），核心思想是： 从底向上回溯，判断当前节点是否为 p 和 q 的最近公共祖先。 为什么可以不显式遍历两个节点？如果 p 是 q 的祖先，递归在访问到 p 时就会返回 p，而不会继续显式地遍历 q。 但这并不会影响正确性。因为： 我们关心的是：当前节点的左子树是否包含一个目标节点，右子树是否包含另一个； 如果只在一个子树中找到了一个非空结果，就继续返回那个节点； 如果两边都找到了非空结果，说明当前节点正好是两者交汇点，即最近公共祖先。 换句话说，返回值的传递就是信息的传播路径，而不是访问状态的标记。 为什么用后序遍历？这个问题的本质是从子树结果中“归纳”出当前节点是否满足祖先条件，这是后序遍历的典型应用场景。 后序遍历的结构：先处理左子树 → 再处理右子树 → 再处理当前节点 这样的遍历方式可以确保： 当前节点能拿到左右子树的返回信息； 决策当前节点是否是“最近公共祖先”时，信息已就绪； 实现“从叶子节点向根汇总”的逻辑判断。 总结：后序遍历适用场景后序遍历适合处理以下类型问题： 问题类型 是否适用 理由 当前节点决策依赖子树结果 ✔ 需要知道左右子树是否含有目标节点后，才能判断当前是否是祖先 子树结果需要合并 ✔ 如计算树高、路径和等，左右结果参与当前计算 只需遍历所有节点 ✘ 如遍历打印、序列化等，前序/中序遍历更直接简洁","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC15%E5%A4%A9%EF%BD%9C%E4%BA%8C%E5%8F%89%E6%A0%91part03/"},{"title":"代码随想录算法训练营第14天｜二叉树Part02","text":"给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 LeetCode106. 从中序与后序遍历序列构造二叉树 1234567891011121314var buildTree = function(inorder, postorder) { if (!inorder.length) return null; const rootVal = postorder.pop(); // 从后序遍历的数组中获取中间节点的值， 即数组最后一个值 let rootIndex = inorder.indexOf(rootVal); // 获取中间节点在中序遍历中的下标 const root = new TreeNode(rootVal); // 创建中间节点 root.left = buildTree(inorder.slice(0, rootIndex), postorder.slice(0, rootIndex)); // 创建左节点 root.right = buildTree(inorder.slice(rootIndex + 1), postorder.slice(rootIndex)); // 创建右节点 return root;}; 上面的代码每层递归定义了新的数组，浪费了一些时间空间。 可以将新数组在原数组中的首尾下标代替新数组实体作为参数在递归中传递： 123456789101112131415161718var buildTree = function(inorder, postorder) { const build = (inLeft, inRight, postLeft, postRight) =&gt; { if (inLeft &gt; inRight) return null; const rootVal = postorder[postRight]; // 相当于 pop 出最后一个值 const root = new TreeNode(rootVal); const rootIndex = inorder.indexOf(rootVal); // 根在中序中的位置 const leftSize = rootIndex - inLeft; // 左子树节点数量 root.left = build(inLeft, rootIndex - 1, postLeft, postLeft + leftSize - 1); // 递归构造左子树（对应 slice(0, rootIndex)） root.right = build(rootIndex + 1, inRight, postLeft + leftSize, postRight - 1); // 递归构造右子树（对应 slice(rootIndex + 1)） return root; }; return build(0, inorder.length - 1, 0, postorder.length - 1);};","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC14%E5%A4%A9%EF%BD%9C%E4%BA%8C%E5%8F%89%E6%A0%91part02/"},{"title":"代码随想录算法训练营第16-20天｜二叉树Part04-07","text":"记录题目： 验证二叉搜索树 二叉搜索树的最小绝对差 删除二叉搜索树中的节点 给你一个二叉树的根节点 root，判断其是否是一个有效的二叉搜索树。 有效二叉搜索树定义如下： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 LeetCode98. 验证二叉搜索树 中序遍历下，输出的二叉搜索树节点的数值是有序序列。 有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 LeetCode530. 二叉搜索树的最小绝对差 二叉搜索树采用中序遍历时其实就是一个有序数组，在一个二叉搜索树上寻找最值、差值的问题，其实就相当于在有序数组上求最值、差值。 对于本题最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组统计出来最小差值。 但其实在二叉搜索树中序遍历的过程中，是可以直接计算的，只需要在递归函数外部使用变量记录前一个节点即可。 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 LeetCode450. 删除二叉搜索树中的节点 这道题目主要涉及到如下两大方面： 如何在 BST 中找到要删除的目标节点； 找到目标节点后，如何删除它，并保持 BST 的结构性质不变。 删除节点的三种基本情况若目标节点存在，删除时需分情况处理： 该节点是叶子节点：直接删除，返回 null； 该节点只有一个子节点：将其子节点接上父节点； 该节点有两个子节点： 找到右子树中的最小节点（中序后继）； 用其值替换当前节点； 在右子树中递归删除这个最小节点。 递归删除的本质优势该题递归实现优于手动寻找父节点的写法，具有如下优势： 避免记录父节点：递归时每次返回的值就是“当前子树删除目标节点后的新子树根”，上层调用自然完成连接更新，无需显式保存父节点指针。 处理逻辑在一次遍历中完成：递归调用过程即自顶向下查找节点，自底向上重建子树结构，不需要“先找目标节点再找其父节点”的两次遍历。 不需特殊处理根节点：根节点若正是要删除的节点，只需返回新的根节点即可，递归天然适配这一情形。 结构更新的函数式范式 递归方式将子问题抽象为“删除后返回新的子树根节点”，上层直接接收作为左或右子树的更新结果，无需外部修改或标记。 标准递归实现123456789101112131415161718192021222324252627282930var deleteNode = function(root, key) { if (!root) return null; if (key &lt; root.val) { // 去左子树找目标节点 root.left = deleteNode(root.left, key); } else if (key &gt; root.val) { // 去右子树找目标节点 root.right = deleteNode(root.right, key); } else { // 找到目标节点，开始删除 if (!root.left &amp;&amp; !root.right) { // 1. 无子节点 return null; } else if (!root.left || !root.right) { // 2. 只有一个子节点 return root.left || root.right; } else { // 3. 有两个子节点 const minNode = getMin(root.right); root.val = minNode.val; // 用右子树最小节点的值替代 root.right = deleteNode(root.right, minNode.val); // 删除该最小节点 } } return root;};// 获取右子树最小节点function getMin(node) { while (node.left) node = node.left; return node;} 设计上的启发 凡是需要“在递归中操作树结构”的问题，都可以采用“返回新的子树根”这一模式，代替显式父节点操作； 当节点结构不变但需要局部更新时，返回值就是“子树更新结果”； 使用中序后继（右子树最小）或中序前驱（左子树最大）都可以替代节点值，保持 BST 性质，前者更常见； 若允许重复值，则应定义“删除策略”（如优先删除左子树中的某个值）； 若采用非递归方式，通常需要显式追踪父节点或构造 dummy 节点模拟根节点处理。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC16-20%E5%A4%A9%EF%BD%9C%E4%BA%8C%E5%8F%89%E6%A0%91part04-07/"},{"title":"代码随想录算法训练营第1天｜数组Part01","text":"给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。 你必须编写一个具有 O(log n) 时间复杂度的算法。 LeetCode704. 二分查找 二分查找的前提条件 数组有序 无重复元素 若存在重复元素，返回的下标可能不唯一，可能需要额外逻辑处理 循环不变量原则二分法的核心是：始终保持区间定义的一致性（即循环不变量）。 常见区间定义有两种： 1. 左闭右闭区间 [left, right] 循环条件：while (left &lt;= right) 中点计算：const mid = left + ((right - left) &gt;&gt; 1) 边界收缩方式： 若 nums[mid] &gt; target：排除右侧 → right = mid - 1 若 nums[mid] &lt; target：排除左侧 → left = mid + 1 2. 左闭右开区间 [left, right) 循环条件：while (left &lt; right) 中点计算：const mid = left + ((right - left) &gt;&gt; 1) 边界收缩方式： 若 nums[mid] &gt; target：排除右侧 → right = mid 若 nums[mid] &lt; target：排除左侧 → left = mid + 1 正确代码示例（左闭右闭区间）12345678910111213var search = function(nums, target) { let left = 0, right = nums.length - 1; while (left &lt;= right) { const mid = left + ((right - left) &gt;&gt; 1); // 避免溢出，更高效 if (nums[mid] === target) return mid; if (nums[mid] &gt; target) { right = mid - 1; } else { left = mid + 1; } } return -1;}; 关键总结 区间定义决定一切： [left, right] 对应 while (left &lt;= right) [left, right) 对应 while (left &lt; right) 始终保证循环内 mid 落在合法区间中 推荐统一使用：mid = left + ((right - left) &gt;&gt; 1) 防止死循环 每次循环要收缩区间 切忌写错为 right = mid（在 [left, right] 情况下会死循环） 为什么向下取整？ 保证 mid 不越界 保证区间逐步缩小 提高计算效率（避免函数调用）","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC1%E5%A4%A9%EF%BD%9C%E6%95%B0%E7%BB%84part01/"},{"title":"代码随想录算法训练营第21天｜二叉树Part08","text":"二叉树总结篇。 遍历方式总结深度优先遍历（DFS） 递归方式：前序（中左右）、中序（左中右）、后序（左右中） 迭代方式：使用栈模拟递归，适用于三种顺序 广度优先遍历（BFS） 使用队列进行层序遍历 可拓展为“每层最大值”“之字形遍历”“最后一层左/右值”等题型 二叉树基本属性问题 题目 解法思路 遍历顺序 0101. 对称二叉树 递归比对左右子树是否对称；队列模拟同步遍历 后序（递归） / 层序 0104. 二叉树的最大深度 返回左右子树最大高度 + 1 后序 / 层序 0111. 二叉树的最小深度 注意忽略不存在的子树 后序 / 层序 0222. 完全二叉树的节点个数 后序递归，或利用完全树高度差剪枝 后序 0110. 平衡二叉树 返回高度同时判断是否失衡 后序 0513. 找树左下角的值 层序遍历记录每层第一个节点；或 DFS 记录最深层左值 层序 or DFS 0404. 左叶子之和 判断左子节点是否是叶子并累加 后序 / 层序 0112. 路径总和 路径累计判断等于目标值 DFS + 回溯 / 栈辅助 一般来说，求“树的整体属性”（如深度、是否平衡、节点数等）适合后序遍历，因为需要依赖子树返回值。 路径型问题（含回溯） 题目 解法思路 说明 0257. 二叉树的所有路径 前序递归记录路径 + 回溯 构建路径字符串，回溯撤销路径 0113. 路径总和 II 前序递归 + 路径数组 + 回溯 找出所有路径和等于目标值的路径 0437. 路径总和 III DFS + 前缀和 + 回溯 路径不限起点，使用前缀和优化 0129. 求根到叶子节点数字之和 前序递归记录数字路径 + 回溯 将路径数字转为整数求和 0112. 路径总和 递归判断是否存在路径和 返回bool，判断是否存在目标路径 虽然有些路径题目并未提及回溯，但本质就是回溯模式。 路径类问题处理策略通常是：前序遍历 + 路径回退。 此外有时候路径回退是可以隐藏在递归参数传递中的。 构造与修改问题 题目 解法思路 说明 0226. 翻转二叉树 交换左右子树指针 前序 or 层序 0106. 从中序与后序遍历构造二叉树 找到中间点递归构造左右子树 分治 + 前序构造思路 0654. 最大二叉树 每次找当前数组最大值为根节点 分治递归 0617. 合并二叉树 同步遍历两个树并合并节点 前序递归 / 层序队列 构造树结构的题目，不论是否显式要求使用“前序遍历”，其核心总是：先构造当前节点，再构造左右子树。 最近公共祖先（LCA） 题目 解法思路 0236. 二叉树的最近公共祖先 后序 + 回溯返回包含目标节点的子树 0235. BST 的最近公共祖先 根据有序性判断节点在哪一侧 二叉搜索树（BST）的性质问题搜索 / 验证 / 转换类题目 题目 解法思路 0700. 二叉搜索树中的搜索 利用有序性，向左/右递归查找 0098. 验证二叉搜索树 中序遍历验证是否递增 0530. 最小绝对差 中序 + 前驱节点保存 0501. 二叉搜索树中的众数 中序统计频率，更新众数集合，适时清空结果集 0538. 把 BST 转换为累加树 反中序遍历 + 累加和 所有利用 BST 有序特性的问题（如最小差值、验证递增、累加转换）几乎都可通过中序遍历实现。 BST 中序遍历 = 有序数组。 BST 的修改与构造 题目 解法思路 0701. 插入操作 按序插入位置，递归返回新子树 0450. 删除操作 删除时分三种情况处理子节点 0669. 修剪 BST 递归返回修剪后的左右子树 0108. 有序数组转 BST 数组中点为根，递归构造 遍历选择指南 问题类型 推荐遍历顺序 选择理由 构造类构造树结构 前序 当前节点必须先于子节点创建 求属性深度、平衡、节点数 后序 需等左右子树返回值才能得出结果 路径类路径总和、所有路径 前序 + 回溯 路径需在递归中积累，并在回溯中清除 搜索树（BST）有序性题目 中序 利用中序遍历的有序性特征","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC21%E5%A4%A9%EF%BD%9C%E4%BA%8C%E5%8F%89%E6%A0%91part08/"},{"title":"代码随想录算法训练营第23天｜回溯算法Part02","text":"记录题目： 分割回文串 组合总和 组合总和 II 回溯算法是“枚举+剪枝”的经典范式，不同题型的关键在于：是否允许重复使用元素、是否存在重复元素、是否需要固定顺序。 这些因素共同决定了递归的展开方式与剪枝/去重策略，掌握其背后的结构抽象，比记住模板更重要。 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 LeetCode131. 分割回文串 回溯法的关键在于划分子问题并搜索所有可能解。 本题中，每一次切割构成一层递归，切割点向后推进，直到指针切到字符串末尾，视为一种合法划分。 思路解析 使用回溯法，从左至右尝试所有切割方案； 每次尝试切一段回文串，若合法，则加入路径，继续下一层递归； 切割线位于索引 i，截取子串范围为 [startIndex, i]； 注意递归函数需传入 i + 1，避免重复切割相同位置。 给你一个无重复元素的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为 target 的所有不同组合，并以列表形式返回。你可以按任意顺序返回这些组合。 candidates 中的同一个数字可以无限制重复选取。如果至少一个数字的被选数量不同，则两种组合视为不同。 LeetCode39. 组合总和 实现方式一：通过 startIndex 控制搜索范围 每层递归从当前位置开始向后枚举； 排序的作用： 提前剪枝：若 sum + candidates[i] &gt; target，可以 break 提前终止； 树层去重：相邻相等元素可直接跳过； 本质上是对组合空间进行“逐层展开”，避免重复枚举前面的数。 实现方式二：按值大小剪枝，无需 startIndex 使用路径末尾 path[path.length - 1] 限制当前可选数字不小于上一个， 从而保持非降序组合； 这是一种值域剪枝技巧，可以规避重复组合而不依赖索引； 因 candidates 中数值无重复，故无需考虑值相同的树层去重。 无论采用哪种方式，都必须先对 candidates 进行升序排序，以确保剪枝和去重逻辑有效运行。 类题对比 题目 使用 startIndex 需要排序 说明 77. 组合 是 否（不强制） 单集合组合，控制起点防止重复 216. 组合总和 III 是 否（不强制） 数字范围固定，使用 startIndex 控制 17. 电话号码的字母组合 否 否（不需要） 多集合各自独立，分别递归 39. 组合总和 否（可选） 是（必须排序） 利用数值剪枝，避免重复组合 给定一个候选人编号的集合 candidates 和一个目标数 target，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 注意：解集不能包含重复的组合。 LeetCode40. 组合总和 II 思路解析此题与上一题的核心区别在于： 每个元素只能使用一次； candidates 中可能存在重复元素，因此需要进行树层去重。 树层去重 vs 树枝去重在解决组合问题的回溯树中，我们常说“同一树层去重，树枝不去重”。这意味着： 树层： 同一层中若某个值已被使用过，则跳过相同值； 树枝： 因为下一层递归来自不同路径，值可重复。 实现关键 对 candidates 排序是去重的前提； 判断去重的条件为： if (i &gt; startIndex &amp;&amp; candidates[i] === candidates[i - 1]) continue; 该判断仅作用于同一树层，避免出现重复组合； 注意剪枝条件：若 sum + candidates[i] &gt; target，可立即跳出当前循环。 去重方式：used[] 与 startIndex 的比较 有些题解使用 used[] 配合如下判断： if (i &gt; 0 &amp;&amp; candidates[i] === candidates[i - 1] &amp;&amp; !used[i - 1]) continue; 这是排列类问题（如 47. 全排列 II ）中的典型用法，用于判断“树枝去重”。但在本题（组合问题）中，只要使用 startIndex 控制树层，就足以完成去重，不需要 used[]。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC23%E5%A4%A9%EF%BD%9C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95part02/"},{"title":"代码随想录算法训练营第22天｜回溯算法Part01","text":"回溯算法本质是一种暴力搜索的方法：它通过不断地尝试各种可能的解决方案， 并在发现不可行的解时回退到之前的状态，继续尝试其他的路径，从而确保枚举出所有可能的答案。 回溯算法的工作原理回溯算法可以抽象为一个 N 叉树的遍历过程。 每一个节点代表一种可能的选择路径，而整棵树覆盖了所有可能的解决方案。 一般而言： 树的宽度：代表在某一层我们面临的选择个数， 通常通过 for 循环实现； 树的深度：对应递归的层数，即每走一步就深入下一层； 回溯算法的基本流程如下： 从根节点出发，做出一个选择； 如果当前选择仍可能构成解，就继续向下探索； 如果遇到不满足条件的情况，立即回溯，撤销上一步选择； 如果所有路径都试过了，还没解，说明无解； 如果找到了一个满足条件的解，将其加入结果集。 这个过程可以用递归来实现。在递归函数中，需要明确以下三个关键点： 递归函数的参数和返回值 递归的终止条件 单层搜索的逻辑 回溯算法范式在回溯题目中，我们可以总结出一个范式： 1234567891011121314151617function backtrack(路径, 选择列表, ...args) { if (终止条件) { // 记录结果 return; } for (let 选择 of 选择列表) { // 做出选择 路径.push(选择); // 递归调用 backtrack(路径, 新的选择列表); // 回溯，撤销选择 路径.pop(); }} 关键点说明： 路径 表示当前选择的集合，通常是一个数组，用于记录搜索过程； 选择列表 表示当前层可供选择的元素集合； 回溯过程始终遵循“做出选择 → 递归深入 → 撤销选择”这一范式； 回溯的核心并不是“剪枝”，而是“尝试 + 回退”的机制，剪枝是优化，而非必要条件； 从遍历角度看，for 循环负责 横向遍历（枚举当前层所有可能选择）， 递归负责 纵向推进（深入每一种路径的下一层）。 回溯法适用的问题类型回溯算法主要应用于“在集合中递归查找子结构”的问题。常见的五类问题如下： 排列问题 给定 N 个元素，找出它们的所有排列方式。 排列强调顺序，[1, 2] 和 [2, 1] 被视为不同结果。 组合问题 给定 N 个元素，从中选出 K 个元素组成一个组合集合。组合不强调顺序。 子集问题 给定一个集合，找出它的所有子集，包含空集和全集。 切割问题 给定一个字符串，按某种规则进行切割，使得每个切割片段满足特定要求（如回文）。 棋盘问题 包括 N 皇后、解数独、迷宫路径等，通常涉及二维空间中的递归回溯搜索。 组合与排列的关键区别在于是否考虑顺序。组合是无序的，排列是有序的。 例如：{1, 2} 与 {2, 1} 在组合中视为同一组，在排列中是两组不同结果。 小结回溯算法是一种通过不断尝试和撤销来遍历所有可能解空间的暴力搜索策略。 它虽然效率不高，但在某些只能枚举的问题上是唯一可行的解法。 掌握回溯算法的关键在于： 明确递归三要素：参数、终止条件、单层逻辑； 学会将问题抽象为树形结构，并识别“横向选择”和“纵向递归”的过程； 熟练掌握通用模板，在模板基础上按题意做定制化修改； 正确认识回溯的本质是穷举搜索，而非高效算法； 通过不断练习不同类型的回溯问题，可以建立起对这类题型的直觉和模型理解， 从而在面对组合类搜索时迅速构造出合理的解法框架。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC22%E5%A4%A9%EF%BD%9C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95part01/"},{"title":"代码随想录算法训练营第24天｜回溯算法Part03","text":"记录题目： 复原 IP 地址 子集 II 递增子序列 全排列 全排列 II 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。有效 IP 地址由四个整数（每个整数位于 0 到 255 之间，且不含前导 0）组成，整数之间用 . 分隔。 LeetCode93. 复原 IP 地址 12345678for(let j = i; j &lt; s.length; j++) { const str = s.slice(i, j + 1); if(str.length &gt; 3 || +str &gt; 255) break; if(str.length &gt; 1 &amp;&amp; str[0] === &quot;0&quot;) break; path.push(str); backtracking(j + 1); path.pop()} 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。 LeetCode90. 子集 II 123456for (let i = startIndex; i &lt; len; i++) { if (i &gt; startIndex &amp;&amp; nums[i] === nums[i - 1]) continue; path.push(nums[i]); backtracking(i + 1); path.pop();} 给定一个整型数组，找到所有该数组的递增子序列，递增子序列的长度至少是 2。数组中的整数范围是 [-100,100]，可能包含重复数字。 LeetCode491. 递增子序列 12345678910let uset = []for(let i = startIndex; i &lt; nums.length; i++) { if((path.length &gt; 0 &amp;&amp; nums[i] &lt; path[path.length - 1]) || uset[nums[i] + 100]) { continue } uset[nums[i] + 100] = true path.push(nums[i]) backtracing(i + 1) path.pop()} 给定一个不含重复数字的序列，返回其所有可能的全排列。 LeetCode46. 全排列 12345678910111213141516var permute = function (nums) { const res = [], path = [], len = nums.length, used = []; const backtracking = () =&gt; { if (path.length === len) res.push(path.slice(0)); for (let i = 0; i &lt; len; i++) { if (used[i]) continue; path.push(nums[i]); used[i] = 1; backtracking(); path.pop(); used[i] = 0; } } backtracking(); return res;}; 给定一个可包含重复数字的序列，返回其所有不重复的全排列。 LeetCode II47. 全排列 12345678910for (let i = 0; i &lt; nums.length; i++) { if ((i &gt; 0 &amp;&amp; nums[i] === nums[i - 1] &amp;&amp; !used[i - 1]) || used[i]) { continue; } used[i] = true; path.push(nums[i]); backtracing(used); path.pop(); used[i] = false;}","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC24%E5%A4%A9%EF%BD%9C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95part03/"},{"title":"代码随想录算法训练营第25天｜回溯算法Part04","text":"记录题目： 重新安排行程 N 皇后 解数独 给定一个机票的字符串二维数组 tickets，其中 tickets[i] = [from, to] 表示从 from 到 to 的航班信息。从 &quot;JFK&quot; 机场出发，返回重新安排后的行程，行程按字典序排列且恰好使用所有机票一次。 LeetCode332. 重新安排行程 N 叉树 Hierholzer 算法 1234567891011121314151617181920212223242526272829303132333435363738var findItinerary = function (tickets) { const result = ['JFK'], map = {}; // 构建邻接表 for (const [from, to] of tickets) { if (!map[from]) { map[from] = []; } map[from].push(to); } // 将目的地按字典序排序 for (const city in map) { map[city].sort(); } function backtracking() { // 如果结果已包含所有航班（n 个票，对应 n + 1 个机场） if (result.length === tickets.length + 1) { return true; } const lastCity = result[result.length - 1]; const destinations = map[lastCity]; if (!destinations || destinations.length === 0) { return false; } for (let i = 0; i &lt; destinations.length; i++) { const nextCity = destinations[i]; // 移除当前航线（表示已使用） destinations.splice(i, 1); result.push(nextCity); if (backtracking()) return true; // 回溯：撤销操作 result.pop(); destinations.splice(i, 0, nextCity); } return false; } backtracking(); return result;}; 如果当前路径成功走完（用了所有票），就 return true，一路向上传递终止； 如果当前路径走死了，就 return false，上一层回退换一条路走。 方法：slice(start, end) 属性 描述 参数形式 截取索引 [start, end) 之间的元素（不含 end） 主要作用 复制子数组 返回值 新数组 是否修改原数组 否 方法：splice(start, deleteCount, ...itemsToAdd) 属性 描述 参数形式 从索引 start 开始，删除 deleteCount 个元素，并插入 itemsToAdd（可选） 主要作用 删除或插入元素 返回值 被删除的元素组成的新数组 是否修改原数组 是 123456789101112131415161718192021222324252627282930function findItinerary(tickets) { // 邻接表：记录每个起点对应的目的地列表（按字典序排序） const graph = new Map(); // 建图 for (const [from, to] of tickets) { if (!graph.has(from)) { graph.set(from, []); } graph.get(from).push(to); } // 对每个出发点的目的地列表进行字典序排序（小的在前） for (const [from, tos] of graph.entries()) { tos.sort(); // sort 默认就是字典序 } const itinerary = []; // 深度优先遍历（Hierholzer 核心） function dfs(from) { const destinations = graph.get(from) || []; // 一直走到没有可去的目的地为止（贪心优先选字典序小的） while (destinations.length &gt; 0) { // 移除最小字典序的目的地并前进 const next = destinations.shift(); dfs(next); } // 回退时将当前节点加入结果（注意：是回退时记录） itinerary.unshift(from); } dfs(&quot;JFK&quot;); // 起点永远是 JFK return itinerary;} Hierholzer 算法依赖“不断从当前节点出发，走完一条尽可能长的路径直到无法继续”，并将走过的节点按回溯顺序压入栈中，最终将所有路径拼接成一条欧拉路径。 接下来说明：为何这种看似“贪心 + 回溯”的策略是正确的，并适用于欧拉路径与回路。 性质一：栈中倒序恰好是欧拉路径的顺序Hierholzer 算法的核心是：在无法再扩展路径（即遇末端节点）时将当前节点压入栈中，这等价于路径的“反向记录”。 对于欧拉路径 若图存在欧拉路径，则起点 s 出度比入度多 1，终点 t 入度比出度多 1。 DFS 从 s 出发，最终会“遇末端”在 t —— 即第一次无法继续扩展的节点。 此时 t 被最早压入栈中，随着后续 DFS 回溯，s 最后入栈。 所以最终栈中为 t → … → s，倒序后得到 s → … → t，即完整的欧拉路径。 对于欧拉回路 欧拉回路所有节点入度 = 出度，路径终点应与起点一致。 从起点 s 出发，DFS 遍历所有边，最终回到 s，此时 s 是最后回溯入栈的节点。 所以栈中为 s → … → s，倒序后仍得到完整的回路路径。 小结无论是欧拉路径还是回路，DFS 终止节点最早入栈，起点最晚入栈， 因此栈倒序即为正向路径。 性质二：“遇末端压栈”是反向路径构造的关键每次 DFS 尽量深入，直到某节点无未访问的出边，称之为“当前末端节点”： 若首次遇末端的是全局终点 t，自然作为路径终点； 若是路径中的中继节点，说明它所有出边都已被走完（“被清空”），此时压入栈中表示这一段路径已完成。 这种构造方式具备如下特征： 当前遇末端的节点，总是当前剩余图中某一条子路径的“终点”。 在将其压入栈中后，相当于“剪掉”这段子路径。 之后如果从主路径上其他节点重新开始 DFS， 会构造新的子路径，并拼接到先前路径中。 因此，“遇末端压栈”其实是不断将路径段按回溯顺序压入结果栈的过程， 最终反转即得完整路径。 性质三：拼接子路径等价于延伸覆盖所有边Hierholzer 算法通过主路径与子路径的拼接，实现对所有边的覆盖。 举例来说，设第一次 DFS 构建出主路径 A → B → C → D，但 B 节点仍有未访问的回路 B → E → F → B。此时： 算法沿主路径回溯，将 D 和 C 压入栈； 回溯至 B 时，发现其仍有出边，于是开始新一轮 DFS，从 B → E → F → B； 再次回到 B 时，出边已清空，开始回溯并将 B、F、E、B 入栈； 最后主路径起点 A 入栈。 此时栈中为 D, C, B, F, E, B, A，反转后得到完整欧拉路径： A → B → E → F → B → C → D 这种拼接操作，实际上等价于在主路径上发现新回路时，将其原地插入主路径中。 由于每条边都只访问一次，且 DFS 时就被删除，整个过程保证不重不漏，构造出完整欧拉路径。 欧拉路径 vs 欧拉回路：算法是否都有效？是的，Hierholzer 算法同样适用于欧拉路径和欧拉回路，差别仅在起点选择与终点处理方式。 类型 起点选择 路径终止位置 DFS 首次遇末端 栈顺序 欧拉路径 out(s) = in(s)+1 终点 t 最早入栈 t ... s 欧拉回路 任一非孤立点 回到起点 起点最后入栈 s ... s 因此，无需区分处理流程，只需正确选择起点即可通用。 附录：为何 Hierholzer 算法高效？相比暴力回溯，Hierholzer 算法不仅更快，而且更结构化。以 “LeetCode 332. 重新安排行程” 为例，其高效性来源于以下几点： 1. 避免无效回溯树枝暴力回溯枚举所有可能路径，会产生许多“失效树枝”，例如提前走到终点导致图剩余部分不可达。而 Hierholzer 只要图满足欧拉条件，就从起点不断延展，遇末端就收集路径，避免了枚举与试错。 2. 反向收集，不做猜测Hierholzer 不会预先构造路径，而是通过“走到底、再回溯”的方式按序收集节点，这种反向构造避免了状态回滚，天然符合栈式操作逻辑。 3. 利用结构性假设：有解就唯一覆盖欧拉图有解意味着存在一条覆盖所有边的路径或回路，Hierholzer 算法正是以此为前提， 一步步剪掉路径段，最后组合为全局解，无需重复判断。 4. 时间复杂度为 O(E)每条边最多访问和删除一次，每个节点最多压入栈一次，整体运行在线性时间内。 因此，Hierholzer 算法是典型的“结构特化”算法：它不追求普适性，而是深度利用欧拉图的特性，从而实现常规回溯难以匹敌的效率。 将 n 个皇后放置在 n×n 的棋盘上，使皇后彼此之间不能攻击（任意两个皇后不能处于同一行、同一列或同一对角线上）。返回所有可能的解决方案。 LeetCode51. N 皇后 123456789101112131415161718const backtrack = (row) =&gt; { if (row === n) { // 已放置完 n 个皇后，构造解 res.push(path.map(col =&gt; '.'.repeat(col) + 'Q' + '.'.repeat(n - col - 1))); return; } for (let col = 0; col &lt; n; col++) { if (cols.has(col) || diag1.has(row - col) || diag2.has(row + col)) continue; // 放置皇后 path.push(col); cols.add(col); diag1.add(row - col); diag2.add(row + col); // ... //...//... 编写一个程序，通过填充空格来解决给定的数独问题。数独的解法需满足： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个 3×3 宫格内只能出现一次。 LeetCode37. 解数独 12345678910111213141516171819202122232425262728293031323334353637383940var solveSudoku = function (board) { const rows = new Array(9).fill(0); const cols = new Array(9).fill(0); const blocks = Array.from({ length: 3 }, () =&gt; new Array(3).fill(0)); const blanks = []; for (let i = 0; i &lt; 9; i++) { for (let j = 0; j &lt; 9; j++) { const num = Number(board[i][j]); if (num) { const mask = 1 &lt;&lt; (num - 1); rows[i] |= mask; cols[j] |= mask; blocks[~~(i / 3)][~~(j / 3)] |= mask; } else { blanks.push([i, j]); } } } const dfs = (k) =&gt; { if (k === blanks.length) return true; const [i, j] = blanks[k]; const bi = ~~(i / 3), bj = ~~(j / 3); const used = rows[i] | cols[j] | blocks[bi][bj]; for (let x = 1; x &lt;= 9; x++) { const mask = 1 &lt;&lt; (x - 1); if (used &amp; mask) continue; board[i][j] = `${x}`; rows[i] |= mask; cols[j] |= mask; blocks[bi][bj] |= mask; if (dfs(k + 1)) return true; board[i][j] = &quot;.&quot;; rows[i] ^= mask; cols[j] ^= mask; blocks[bi][bj] ^= mask; } return false; }; dfs(0);}; 总结：回溯算法回溯是递归的副产品，只要有递归就会有回溯，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。 优化回溯算法只有剪枝一种方法。 回溯经典题型复杂度分析 子集问题分析: 时间复杂度：O(2ⁿ) 每个元素有“取”与“不取”两种状态，组合总数为 2ⁿ。 空间复杂度：O(n) 递归深度为 n，栈空间为 O(n)，每层额外开销为常数级。 排列问题分析: 时间复杂度：O(n!) 每一层有 n 个分支，下一层为 n-1，依此类推，共 n! 种排列。 空间复杂度：O(n) 递归深度为 n，系统栈使用 O(n) 空间。 组合问题分析: 时间复杂度：O(2ⁿ) 属于子集问题的变形，最坏情况下为 2ⁿ。 空间复杂度：O(n) 递归深度为 n，其他开销为常数级。 N 皇后问题分析: 时间复杂度：O(n!) 表面上看是 O(nⁿ)，但因剪枝优化，最坏情况下为 n!。 空间复杂度：O(n) 递归深度为 n，仅需记录当前皇后摆放状态。 解数独问题分析: 时间复杂度：O(9^m) m 是空格（’.’）的数量，每个位置最多尝试 9 种数字。 空间复杂度：O(n²) 最多递归 n² 层（即 81），每次调用只处理一个空格。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC25%E5%A4%A9%EF%BD%9C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95part04/"},{"title":"代码随想录算法训练营第3天｜链表Part01","text":"在刷到 LeetCode 707「设计链表」题目时，我借此机会深入复习了 JavaScript 中的类（class）机制。 过程中发现，class 语法表面看似简洁，但其底层原理与传统的函数构造器密切相关。 为了更加深刻地理解这一点，本文尝试从语法、机制和语言设计的角度系统梳理 JavaScript 中类的本质。 理解 JavaScript 类的本质：构造函数、语法糖与对象工厂 JS 中的类究竟是什么？在 JavaScript 中，类并不是像 Java、C++ 那样的“类型定义”，而更像是一个「对象工厂」：一个用于生成对象的函数，外加一套方法共享机制。 123456789class MyClass { constructor(name) { this.name = name; } greet() { console.log('Hello, ' + this.name); }} 以上语法中的 constructor 其实是一个特殊的函数，它在用 new 创建实例时会被自动调用。这个类的本质可以还原为如下的传统构造函数写法： 1234567function MyClass(name) { this.name = name;}MyClass.prototype.greet = function () { console.log('Hello, ' + this.name);}; 这说明了：JavaScript 中的类，其本质仍是构造函数（Function），配合原型（prototype）来实现“方法共享”。 class 只是语法糖吗？是的。从功能实现角度来说，class 是对构造函数 + 原型链的语法层封装，其核心行为并没有发生根本改变。 但 ES6 引入 class 之后，带来了一些细节变化，需要明确区分： 差异点 构造函数写法 class 写法 是否变量提升（hoisting） ✅ 是函数，可提前访问 ❌ class 不提升 是否可作普通函数调用 ✅ Fn() 合法 ❌ ClassName() 报错 是否自动启用严格模式 ❌ 默认非严格 ✅ 强制启用 strict mode 方法是否可被枚举 ✅ prototype 方法可枚举 ❌ class 方法不可被枚举 尽管行为一致，语法糖依旧有其意义 —— 它使得面向对象编程更接近 Java 或 C#，也更具可维护性。 构造函数：不是结构体，但行为相似我们常写的链表节点： 1234function ListNode(val, next) { this.val = val; this.next = next;} 或者： 123456class LinkNode { constructor(val, next) { this.val = val; this.next = next; }} 二者从功能上看是等价的：都定义了一个用于构造链表节点的工厂函数，并且都可通过 new 创建对象。 虽然 JS 没有“结构体”这个概念，但这些函数确实扮演了结构体构造器的角色：生成一组字段数据的对象，并可通过 prototype 共享方法。这种“结构体 + 方法”的组合体现了面向对象设计的基本思想。 函数也是对象吗？为什么可以被 new？这部分常令人困惑，尤其是 JS 中「一切皆对象」的语言哲学。 123function foo() {}console.log(typeof foo); // &quot;function&quot;console.log(foo instanceof Object); // true 在 JS 中，函数是一种特殊类型的对象，具有以下属性： 可以拥有自己的属性（比如 foo.bar = 123）。 可以作为构造函数通过 new 使用。 可以被赋值、作为参数传递、返回等等。 new 一个函数时，会经历以下过程（简化版）： 12345678910111213141516function MyConstructor(name) { this.name = name; // this 是函数执行时动态绑定的一个对象引用}const obj = new MyConstructor('Alice');// new 做的事情就是：调用一个函数，并将其作为“构造函数”使用，它内部会创建一个新的对象并赋值给函数中的 this，以完成“构造”的含义// 背后等价：const obj = {}; // ① 创建一个空对象obj.__proto__ = MyConstructor.prototype; // ② 设置它的原型指向构造函数的 prototypeMyConstructor.call(obj, 'Alice'); // ③ 调用构造函数，this绑定为 obj，name='Alice'// 在把 MyConstructor 作为“构造函数”使用时，把 this 设置为 obj，并传入参数 'Alice'// Function.prototype.call(thisArg, ...args) 是：// 让你 “以某个对象为 this 执行函数”，这就是构造函数调用的关键return obj; // ④ 返回 obj 这个对象（除非构造函数手动返回了别的对象）// 在这个语句中，this 指向 obj，意味着构造函数内部的 this.name = name，实际上是 obj.name = 'Alice' 即使函数体中什么都不写，也可以用 new 调用并得到一个空对象： 12function Empty() {}const e = new Empty(); // e =&gt; {} 所以 new 并不依赖于函数体中是否使用了 this，但只有使用 this 才能对实例对象进行赋值初始化。 建议掌握的关键知识点总结 概念 说明 类的本质 构造函数 + 原型方法 构造函数与类的等价性 语法糖，但行为一致 new 的底层机制 创建对象 + 绑定原型 + 执行构造函数 函数是对象 可拥有属性，可被 new 类方法的挂载位置 挂载在 prototype 上 class 的语义变化 更严格的行为，不能提升等 结语JS 的类看似简单，但背后连接的是函数、对象、原型链等多个核心机制。掌握这些机制，不只是为了写出链表这样的题，更重要的是在构建组件、封装逻辑、掌握框架（如 React 中类组件）时，能深入理解其行为。 不要满足于“可以写 class”，而要能回答：“它的本质是什么？”","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC3%E5%A4%A9%EF%BD%9C%E9%93%BE%E8%A1%A8part01/"},{"title":"代码随想录算法训练营第2天｜数组Part02","text":"记录题目： 长度最小的子数组 螺旋矩阵 II 区间和 给定一个含有 n 个正整数的数组和一个正整数 target。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0。 LeetCode209. 长度最小的子数组 同样是双指针，滑动窗口是暴力解法的优化。 通过 x === Infinity 或 x === -Infinity 判断是否为无穷值。 滑动窗口的时间复杂度：每个元素在滑动窗后进来操作一次，出去操作一次，所以时间复杂度是 2 × n 也就是O(n)。 给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix。 LeetCode59. 螺旋矩阵 II 两种创建二维数组方法的对比： 两种创建二维数组（生成 n×m 矩阵）的方法对比： 方法 new Array(n).fill(0).map(() =&gt; new Array(m).fill(0)) Array.from({ length: n }, () =&gt; new Array(m).fill(0)) 初始化方式 先生成一维数组并填充，再用 map 替换为长度为 m 的子数组 从类数组对象生成，回调函数创建长度为 m 的子数组 空槽处理 fill(0) 确保每个元素非空，map 可正常执行 不存在空槽问题，直接遍历索引 性能 多一次 fill(0)，性能略低 略优，略微更简洁高效 兼容性 ES6+，现代浏览器与 Node.js 支持 ES6+，兼容性相同 题目描述：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。 输入描述：第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b &gt; = a），直至文件结束。 输出描述：输出每个指定区间内元素的总和。 LeetCode58. 区间和 Node.js 输入输出处理详解12345678910111213141516171819202122232425262728293031323334353637// 引入 readline 模块，用于逐行读取标准输入const readline = require(&quot;readline&quot;);// 创建接口：绑定标准输入输出const rl = readline.createInterface({ input: process.stdin, output: process.stdout});const inputs = []; // 用于存储所有输入的行// 每读入一行，就推入数组rl.on(&quot;line&quot;, (line) =&gt; { inputs.push(line.trim());});// 所有输入读取完毕后触发此事件（如 Ctrl+D），在这里处理逻辑rl.on(&quot;close&quot;, () =&gt; { // 你可以在这里处理所有读取完的数据 // 示例：处理第1行数字、第2行数组 const n = parseInt(inputs[0]); const arr = inputs[1].split(&quot; &quot;).map(Number); // 处理结果并输出 // console.log(&quot;n =&quot;, n); // console.log(&quot;arr =&quot;, arr); const res = deal(inputs); // 打印结果 console.log(res);});// 对传入的数据进行处理function deal(inputs) { // ... return res;} Node.js 输入处理的核心步骤 创建读取接口：readline.createInterface() 绑定标准输入输出流 监听 line 事件：逐行读取输入，存入数组等数据结构 监听 close 事件：在输入结束后处理数据 数据解析：将字符串转换为数值、数组等类型，根据需求进行处理 数组经典题型复杂度分析 二分法查找： 暴力解法时间复杂度：O(N) 逐个查找目标值，最坏情况下遍历整个数组。 二分法时间复杂度：O(logN) 基于有序数组，每次折半查找，大幅缩小查找范围。 双指针法（例如：快慢指针法）： 暴力解法时间复杂度：O(N²) 通常涉及双重循环进行配对或区间遍历。 双指针时间复杂度：O(N) 快慢指针或首尾夹逼只需一次遍历即可处理问题。 滑动窗口（本质为双指针法的一种）： 暴力解法时间复杂度：O(N²) 枚举所有区间，逐个求和或判断。 滑动窗口时间复杂度：O(N) 利用窗口移动时的状态维护，只需遍历一次。 模拟行为： 主要原则：循环不变量原则 每一步操作都保持某种不变量成立，确保逻辑的正确性。 前缀和： 主要用途：减少重复计算，提高区间求和效率。 用途一：求数组前 i 个数之和 通过维护前缀和数组 sum[i] = nums[0] + ... + nums[i-1]。 用途二：求任意区间 [i, j] 的和 使用公式 sum[j+1] - sum[i] 实现 O(1) 查询。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC2%E5%A4%A9%EF%BD%9C%E6%95%B0%E7%BB%84part02/"},{"title":"代码随想录算法训练营第6天｜哈希表Part01","text":"JavaScript 中常见的四种哈希结构在解决哈希相关问题时，JavaScript 提供了四种常见的数据结构： 数组（Array） 对象（Object） 集合（Set） 映射（Map） 我们分别来看它们在哈希法中的应用与特点。 数组 Array数组是 JavaScript 中最基础的数据结构，可以使用下标快速访问元素，性能高，代码简洁。适用于下标直接映射的场景，比如小范围的整数索引。 123456789101112131415161718192021const arr = [];// 添加元素arr[1] = 'apple';arr[3] = 'banana';// 获取元素console.log(arr[1]); // 输出: apple// 检查是否存在console.log(arr[1] !== undefined); // trueconsole.log(arr[2] !== undefined); // false// 删除元素delete arr[1];console.log(arr[1]); // undefined// 获取长度（注意稀疏数组的特殊性）// 稀疏数组：数组中有一些“中间的索引”没有实际的元素（不是 undefined，是根本没定义过）// 稀疏数组的特殊性：是指 JavaScript 中数组的一个非直觉性特征：数组的 .length 不代表“实际有值的元素个数”，而是“最大索引 + 1”console.log(arr.length); // 4 然而，数组并不适合用于存储非整数类型的键值对。因此在哈希场景中，数组只适用于索引为整数的映射问题。 对象 Object对象是 JavaScript 中最传统的键值对结构，底层实现通常基于哈希表。对象的键只能是字符串或 Symbol，数字键会被自动转换为字符串。 1234567891011121314151617181920212223242526272829const obj = {};// 添加/设置属性obj.name = 'Alice';obj['age'] = 25;obj[123] = 'number key'; // 123 会转换为字符串 &quot;123&quot;// 获取属性console.log(obj.name); // Aliceconsole.log(obj['age']); // 25console.log(obj[123]); // number key// 检查属性是否存在console.log('name' in obj); // trueconsole.log(obj.hasOwnProperty('name')); // trueconsole.log(obj.height !== undefined); // false// 在 JavaScript 中，对象属性访问有两种方式：// 点操作符（dot notation）：obj.propName，点操作符后面必须是一个合法的标识符// 中括号操作符（bracket notation）：obj[&quot;propName&quot;]，里面是字符串表达式或变量，没有标识符限制// 删除属性delete obj.age;console.log(obj.age); // undefined// 获取所有键console.log(Object.keys(obj)); // ['123', 'name']// 获取所有值console.log(Object.values(obj)); // ['number key', 'Alice'] 对象适用于需要快速查找的键值对场景，但键的类型有限制，且原型链可能带来一些意外的属性。 集合 Set集合（Set）是 ES6 引入的一种结构，用于存储不重复的值。底层实现是哈希表，支持高效的查找、插入和删除。 12345678910111213141516171819202122232425262728const set = new Set();// 添加元素set.add('apple');set.add('banana');set.add('apple'); // 自动去重，不会重复添加// 检查是否存在console.log(set.has('apple')); // trueconsole.log(set.has('orange')); // false// 删除元素set.delete('banana');console.log(set.has('banana')); // false// 获取大小console.log(set.size); // 1// 清空集合set.clear();console.log(set.size); // 0// 批量添加const fruits = new Set(['apple', 'banana', 'orange']);console.log(fruits.size); // 3// 遍历fruits.forEach(fruit =&gt; console.log(fruit)); 如果你需要一个高效、不重复的集合结构来快速查找或去重，Set 是最佳选择。 映射 MapMap 是键值对（key-value）结构，允许使用任意类型的键（不仅限于字符串）。同样是基于哈希表实现，具有 O(1) 的查找和修改性能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const map = new Map();// 设置键值对map.set('name', 'Alice');map.set('age', 25);map.set(123, 'number key'); // 支持数字键map.set(true, 'boolean key'); // 支持布尔键// 获取值console.log(map.get('name')); // Aliceconsole.log(map.get(123)); // number keyconsole.log(map.get(false)); // undefined// 检查键是否存在console.log(map.has('name')); // trueconsole.log(map.has('height')); // false// 删除键值对map.delete('age');console.log(map.has('age')); // false// 获取大小console.log(map.size); // 3// 清空映射map.clear();console.log(map.size); // 0// 批量初始化const userMap = new Map([ ['name', 'Bob'], ['age', 30], ['city', 'New York']]);// 遍历userMap.forEach((value, key) =&gt; { console.log(`${key}: ${value}`);});// 获取所有键console.log([...userMap.keys()]); // ['name', 'age', 'city']// 获取所有值console.log([...userMap.values()]); // ['Bob', 30, 'New York'] 相比对象（{}），Map 支持任意类型的键，并且迭代更方便，是现代 JavaScript 中处理哈希映射的首选。 性能对比与选择建议 数据结构 键类型限制 时间复杂度 适用场景 Array 整数索引 O(1) 小范围整数索引映射 Object 字符串/Symbol O(1) 传统键值对，兼容性好 Set 任意类型 O(1) 需要去重的集合 Map 任意类型 O(1) 现代键值对映射 总结与建议 场景 建议数据结构 索引小范围整数 Array 字符串键的简单映射 Object 需要去重的列表 Set 任意类型 key 的键值对映射 Map 兼容老代码，简单映射需求 Object JavaScript 的 Set 和 Map 是哈希法在 JS 中的现代实现，配合 Array 和 Object 可以应对大多数需要高效查找、插入、删除的场景。在选择时，优先考虑 Map 和 Set，除非有特殊的兼容性需求或性能要求。 哈希碰撞一般哈希碰撞有两种解决方法， 拉链法和线性探测法。 拉链法发生冲突的元素都被存储在链表中，要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。 LeetCode242. 有效的字母异位词 123456789101112131415161718192021222324var isAnagram = function(s, t) { if(s.length !== t.length) return false; let char_count = new Map(); for(let item of s) { char_count.set(item, (char_count.get(item) || 0) + 1) ; // 优雅的计数更新 // 使用 (char_count.get(item) || 0) 处理键不存在的情况 // 避免了繁琐的 if-else 判断，代码更简洁 // 等价于：char_count.has(item) ? char_count.get(item) + 1 : 1 } for(let item of t) { if(!char_count.get(item)) return false; // 巧妙的存在性检查 // !char_count.get(item) 同时检查了两种情况： // 1. 键不存在（get返回undefined，!undefined = true） // 2. 键存在但值为0（!0 = true） // 这比分别检查 has() 和计数值更加高效 char_count.set(item, char_count.get(item) - 1); // 计数递减策略 // 每使用一个字符就将其计数减1，避免了最后的验证步骤 // 这种&quot;边验证边消费&quot;的思路非常优雅 } return true;}; 给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 LeetCode349. 两个数组的交集 12345678910111213141516/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */var intersection = function (nums1, nums2) { const set1 = new Set(nums1), res = new Set(); for (const num of nums2) { set1.has(num) &amp;&amp; res.add(num); } // 循环 比 迭代器快 // for(let i = nums2.length - 1; i &gt;= 0; i--) { // nums1Set.has(nums2[i]) &amp;&amp; resSet.add(nums2[i]); // } return Array.from(res);}; JavaScript 的迭代器（如for...of、forEach）是基于迭代协议（Symbol.iterator）实现的，每次迭代都会执行以下操作： 创建迭代器对象 调用next()方法 检查done状态 处理闭包和上下文信息 这些操作会产生额外的性能开销，尤其是在处理大量数据时。相比之下，传统for循环直接通过索引访问数组元素，没有中间层的抽象，因此更高效。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC6%E5%A4%A9%EF%BD%9C%E5%93%88%E5%B8%8C%E8%A1%A8part01/"},{"title":"代码随想录算法训练营第4天｜链表Part02","text":"记录题目： 两两交换链表中的节点 删除链表的倒数第 N 个结点 环形链表 II 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即只能进行节点交换）。 LeetCode24. 两两交换链表中的节点 注意递归版本代码，面试可能让再撕。 迭代法 递归法 12345678910111213var swapPairs = function (head) { let dummy = new ListNode(null, head); if (!head || !head.next) return head; let pre = dummy, cur, next; while (pre.next &amp;&amp; pre.next.next) { cur = pre.next, next = pre.next.next; cur.next = next.next; next.next = cur; pre.next = next; pre = cur; } return dummy.next;}; 12345678var swapPairs = function (head) { if (!head || !head.next) return head; let cur = head, next = head.next; head.next = next.next; next.next = cur; cur.next = swapPairs(cur.next); return next;}; 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 LeetCode19. 删除链表的倒数第 N 个结点 哨兵节点可以消除特判逻辑。 可以借助 n = 1 时的情况辅助思考。 给定一个链表的头节点 head，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改链表。 LeetCode142. 环形链表 II A = (n - 1) (B + C) + C 意味着只要从碰撞点和起点以同样的速度扫描，下次碰撞点一定是环的入口节点。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC4%E5%A4%A9%EF%BD%9C%E9%93%BE%E8%A1%A8part02/"},{"title":"代码随想录算法训练营第27天｜贪心算法Part01","text":"若问题可以分解成若干个子问题，并且每个子问题的最优解可以堆叠出全局最优解，那么就可以尝试使用贪心算法。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC27%E5%A4%A9%EF%BD%9C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95part01/"},{"title":"代码随想录算法训练营第8天｜字符串Part01","text":"记录题目： 反转字符串 II 替换数字 反转字符串 II 替换数字 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 LeetCode541. 反转字符串 II 123456789101112var reverseStr = function(s, k) { const len = s.length; let resArr = s.split(&quot;&quot;); for(let i = 0; i &lt; len; i += 2 * k) { // 每隔 2k 个字符的前 k 个字符进行反转 let l = i - 1, r = i + k &gt; len ? len : i + k; while(++l &lt; --r) [resArr[l], resArr[r]] = [resArr[r], resArr[l]]; // 反转数组 arr 中从 [left, right] 的元素 // let l = left - 1, r = right + 1; // while (++l &lt; --r) [arr[l], arr[r]] = [arr[r], arr[l]]; } return resArr.join(&quot;&quot;);}; 题目描述 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为 number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。 输入描述 输入一个字符串 s，s 仅包含小写字母和数字字符。 输出描述 打印一个新的字符串，其中每个数字字符都被替换为了 number。 卡码网54. 替换数字 很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后再从后向前进行操作。 优点： 不用申请新数组。 从后向前填充元素，避免了从前向后填充元素时， 每次添加元素都要将添加元素之后的所有元素向后移动的问题。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC8%E5%A4%A9%EF%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2part01/"},{"title":"代码随想录算法训练营第7天｜哈希表Part02","text":"记录题目： 三数之和 四数之和 赎金信 三数之和 四数之和 赎金信 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 LeetCode15. 三数之和 在 threeSum 中，必须注意值和下标的区别，三元组加入结果后要及时移动指针并去重， 否则容易造成重复结果或死循环。 提前终止无效枚举 if (nums[i] &gt; 0) break; 这条语句的威力非常大！ nums 是升序的，一旦最小值都大于 0， 后面 nums[i] + nums[left] + nums[right] &gt; 0 一定永远不会等于 0。 所以这条剪枝可以提前跳出主循环，直接减少上百上千次不必要的遍历。 时间复杂度虽然还是 O(n²)，但实际遍历次数可能减少一半甚至更多。 即使是 O(n²)，也能在工程实现上有非常明显的“快慢之分”！这种常数项优化在刷题实战中非常关键。 对于 sum 不等于 0 的情况， left 和 right 不用去重，因为这个组合不会被推入结果数组。 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 LeetCode18. 四数之和 去重条件 在固定 j 时如果使用： 12345678910// ...for (let i = 0; i &lt; len - 3; i++) { if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue; for (let j = i + 1; j &lt; len - 2; j++) { if (j &gt; 0 &amp;&amp; nums[j] === nums[j - 1]) continue; // 去重条件错误，会跳过合法组合 // 这种写法下标 j - 1 可能未曾被 j 指向过，但却会判断 j 指向过相同数而 continue let left = j + 1, right = len - 1; while (left &lt; right) {// ... 这里的 j &gt; 0 是错误的，应该是： 1if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) continue; 原因：我们要确保在同一个 i 下，从 i+1 开始的第一个合法 j 被保留，后续重复的才跳过。 剪枝（提前结束判断）可提高效率 在 LeetCode 中，fourSum 数据范围比较大，加入剪枝逻辑可以显著提升运行速度，例如： 12345// 最小可能值 &gt; target，直接 breakif (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) break;// 最大可能值 &lt; target，直接跳过if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] &lt; target) continue; 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 LeetCode383. 赎金信 charCodeAt() 是 JavaScript 字符串对象的内置方法， 用于返回指定位置字符的 Unicode 编码（UTF-16 编码单元）。 语法： 1str.charCodeAt(index) str：目标字符串 index（可选）：字符位置索引（从 0 开始），默认值为 0 特性 详情 返回值类型 数字（Unicode 编码值） 默认参数 index=0 索引越界 返回 NaN 处理代理对 需配合 codePointAt() 常见用途 字符编码转换、加密、字符串处理 如果需要处理复杂的 Unicode 字符（如表情符号），建议优先使用 codePointAt()。对于普通 ASCII 字符，charCodeAt() 已经足够高效。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%93%88%E5%B8%8C%E8%A1%A8/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC7%E5%A4%A9%EF%BD%9C%E5%93%88%E5%B8%8C%E8%A1%A8part02/"},{"title":"代码随想录算法训练营第9天｜字符串Part02","text":"记录题目： 反转字符串中的单词 右旋字符串 找出字符串中第一个匹配项的下标 对于数组，不方便使用模拟时，可以观察操作是否可以分解为多个反转实现。 反转字符串中的单词 右旋字符串 给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。 LeetCode151. 反转字符串中的单词 字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，将字符串中后 k 个字符移到前面，实现字符串的右旋转操作。 例如： 输入：”abcdefg” 和整数 2 输出：”fgabcde” 卡码网55. 右旋字符串 何时可以考虑“用多个反转实现”？可以在遇到以下场景时主动问自己： 场景 是否可考虑用反转实现？ 举例 顺序整体调整（旋转、调头） YES 右旋字符串、反转单词 局部搬移或重复移动 YES 将后半部分移到前面 不能开新数组 YES 原地操作要求，推荐 reverse 模式 每次操作都是“范围交换” YES 将一段一段翻转、调换 如何自发产生“用反转实现”的思路？ 步骤 要做的事 ① 观察目标状态和初始状态结构 ② 问自己：能否通过“反转”一步步得到？ ③ 小规模模拟 + index 分析 ④ 总结归纳成模式，下次复用 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1。 LeetCode28. 找出字符串中第一个匹配项的下标 在实现 KMP 算法时，我使用的 next 数组定义为：next[i] 表示字符串从下标 0 到 i 这一闭区间 [0, i] 中，最长相等前后缀的长度。 在构造 next 数组的过程中，较难理解的一点是：在当前位置 i 的字符与当前前缀末位 j 不相等时，需要将 j 回退为 next[j - 1]。这一操作的本质是：我们试图构造以 arr[i] 结尾的子串 [0, i] 的最长相等前后缀。若当前 arr[i] !== arr[j]，说明此前构造的前缀（长度为 j）无法继续延伸，此时不应直接放弃，而是寻找次长的前缀尝试匹配。 这等价于将原问题转化为：寻找 j 所代表的前缀（即 [0, j - 1]）自身的最长相等前后缀，并尝试将 arr[i] 追加其后，看是否能形成新的匹配。 因此，令 j = next[j - 1]，继续尝试，直到 arr[i] === arr[j] 或 j 回退为 0。 这正是 KMP 算法在构造 next 数组时最精妙的地方：充分利用已知的匹配结构，避免重复计算，逐步回退尝试较短的匹配前缀。这一过程本质上是一种“匹配状态的继承”。","link":"/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC9%E5%A4%A9%EF%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2part02/"},{"title":"动态规划算法在 JavaScript 中的应用","text":"在编程和算法设计中，动态规划（Dynamic Programming, DP）是一种强大的技术，用于解决复杂的优化问题。本文将详细介绍动态规划的基本概念、核心思想，并通过一个具体的例子来展示如何在 JavaScript 中实现动态规划。同时，我们还将对比动态规划与其他常见算法（如分治法）的不同之处。 什么是动态规划？动态规划是一种通过把原问题分解为相互重叠的子问题来求解复杂问题的方法。它通常用于优化问题，通过存储子问题的解来避免重复计算，从而提高算法的效率。 动态规划的核心思想 重叠子问题：子问题之间不是独立的，而是相互重叠的。这意味着某些子问题会被多次计算。 最优子结构：问题的最优解可以由其子问题的最优解组合而成。 状态转移：通过一个状态转移方程来描述子问题之间的关系。 存储子问题的解：使用一个表（通常是数组或哈希表）来存储子问题的解，以便后续直接使用。 动态规划的应用场景动态规划广泛应用于各种优化问题，例如背包问题、最长公共子序列、斐波那契数列等。本文将以一个经典的房屋盗窃问题（House Robber）为例，展示如何在 JavaScript 中实现动态规划。 房屋盗窃问题假设你是一个专业的强盗，计划抢劫沿街的房屋。每个房屋都存放有一定数量的现金，但相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被强盗闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 动态规划解决方案 定义状态： dp[i] 表示到第 i 个房屋为止，可以抢到的最大金额。 初始化： dp[0] = nums[0]：只有一个房屋时，最大金额就是该房屋的金额。 dp[1] = max(nums[0], nums[1])：有两个房屋时，最大金额是这两个房屋中金额较大的那个。 状态转移方程： 对于第i 个房屋，有两种选择： 不抢劫第 i 个房屋，最大金额是 dp[i - 1]。 抢劫第 i 个房屋，最大金额是 dp[i - 2] + nums[i]。 因此，dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])。 返回结果： 最终结果是 dp[len - 1]，即最后一个房屋为止的最大金额。 代码实现123456789101112131415161718192021222324252627282930313233/** * @param {number[]} nums * @return {number} */var max = function (a, b) { return a &gt; b ? a : b;}var rob = function (nums) { // dp[i] 代表到 i 下标元素为止，可以取到的最大值 let len = nums.length; let dp = new Array(len); // 边界条件处理 if (len === 0) return 0; if (len === 1) return nums[0]; dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (let i = 2; i &lt; len; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[len - 1];};// 测试用例console.log(rob([1, 2, 3, 1])); // 输出: 4console.log(rob([2, 7, 9, 3, 1])); // 输出: 12console.log(rob([0])); // 输出: 0console.log(rob([1])); // 输出: 1console.log(rob([])); // 输出: 0 逻辑验证 基础案例： 当 nums 为空时，返回 0。 当 nums 只有一个元素时，返回该元素的值。 当 nums 有两个元素时，返回这两个元素中较大的那个。 状态转移方程的正确性： dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])： dp[i - 2] + nums[i] 表示抢劫第 i 个房屋，此时不能抢劫第 i - 1 个房屋，最大金额是 dp[i - 2] 加上 nums[i]。 dp[i - 1] 表示不抢劫第 i 个房屋，最大金额是 dp[i - 1]。 选择这两者中的较大值作为 dp[i] 的值。 递归关系的验证： 通过递归关系，我们可以逐步计算出每个 dp[i] 的值，最终得到 dp[len - 1]，即最大金额。 示例验证假设 nums = [2, 7, 9, 3, 1]，我们手动计算一下 dp 数组的值： dp[0] = nums[0] = 2 dp[1] = max(nums[0], nums[1]) = max(2, 7) = 7 dp[2] = max(dp[0] + nums[2], dp[1]) = max(2 + 9, 7) = max(11, 7) = 11 dp[3] = max(dp[1] + nums[3], dp[2]) = max(7 + 3, 11) = max(10, 11) = 11 dp[4] = max(dp[2] + nums[4], dp[3]) = max(11 + 1, 11) = max(12, 11) = 12 最终结果是 dp[4] = 12，这是正确的最大金额。 动态规划 vs 分治法分治法分治法（Divide and Conquer）是一种将问题分解为若干个规模较小的相同子问题，递归地解决这些子问题，然后将子问题的解合并成原问题的解的方法。 主要特点 独立子问题：子问题之间是独立的，互不影响。 递归：通常使用递归来解决子问题。 合并：将子问题的解合并成原问题的解。 应用场景 经典问题：快速排序、归并排序、二分查找、大整数乘法等。 分解问题：适用于可以自然分解为独立子问题的情况。 动态规划 vs 分治法 子问题的性质： 动态规划：子问题之间重叠，需要存储子问题的解以避免重复计算。 分治法：子问题之间独立，不需要存储子问题的解。 解题过程： 动态规划：通常从底向上（自底向上）解决问题，逐步构建最终解。 分治法：通常从顶向下（自顶向下）解决问题，递归地分解问题，再合并子问题的解。 存储需求： 动态规划：需要额外的空间来存储子问题的解。 分治法：通常不需要额外的空间来存储子问题的解，但递归调用栈会占用一定的空间。 适用问题： 动态规划：适用于具有最优子结构和重叠子问题的问题，通常用于优化问题。 分治法：适用于可以自然分解为独立子问题的问题，通常用于排序、查找等问题。 示例对比动态规划示例：斐波那契数列12345678function fibonacci(n) { let dp = new Array(n + 1).fill(0); dp[1] = 1; for (let i = 2; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n];} 分治法示例：快速排序123456789101112131415161718192021function quickSort(arr, left = 0, right = arr.length - 1) { if (left &lt; right) { const pivotIndex = partition(arr, left, right); quickSort(arr, left, pivotIndex - 1); quickSort(arr, pivotIndex + 1, right); } return arr;}function partition(arr, left, right) { const pivot = arr[right]; let i = left - 1; for (let j = left; j &lt; right; j++) { if (arr[j] &lt; pivot) { i++; [arr[i], arr[j]] = [arr[j], arr[i]]; } } [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]]; return i + 1;} 总结通过动态规划，可以将问题分解为子问题，并通过状态转移方程逐步求解，最终得到了全局最优解。这种方法的时间复杂度是 O(n)，空间复杂度也是 O(n)，可以通过进一步优化将空间复杂度降低到 O(1)。","link":"/%E4%BB%A3%E7%A0%81%E5%BF%83%E5%BE%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E5%9C%A8-javascript-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"Icarus 用户指南｜CDN 提供商","text":"选择合适的CDN提供商可以大幅度减少网站访客的网页加载时间。 Icarus为你提供了几种内置的CDN提供商来承载Icaurs所用到的第三方库和资源文件的加载。 下面的CDN功能由ppoffice/hexo-component-inferno提供，完整的支持提供商列表和配置详情以其为准。 内置CDN提供商目前，Icarus提供如下的内置CDN服务提供商： JavaScript库CDN cdnjs.com (cdnjs) jsDelivr (jsdelivr) UNPKG (unpkg) loli.net (loli) Web字体CDN Google Fonts (google) loli.net (loli) font.im (fontim) 中国科学技术大学 (ustc) FontAwesome图标CDN FontAwesome 5 (fontawesome) loli.net (loli) 默认的CDN服务提供商配置为： _config.icarus.yml1234providers: cdn: jsdelivr fontcdn: google iconcdn: fontawesome 自定义CDN提供商除此之外，你还可以通过URL模板来自定义CDN提供商。 每种类别提供商的模板格式如下所示： JavaScript库CDNCDN URL模板1https://some.cdn.domain.name/${package}/${version}/${filename} 你需要将实际的包名称，包版本号，和文件相对路径替换为${package}， ${version}，和${filename}占位符。 例如，如下JavaScript库的URL地址： UNPKG CDN URL示例1https://unpkg.com/d3@5.7.0/dist/d3.min.js 可以被概括成： UNPKG CDN URL模板1https://unpkg.com/${package}@${version}/${filename} 一些CDN提供商可能采用不同的URL形式。 例如，moment.js库在CDN.js上有着如下的URL形式： CDN.js CDN URL示例1https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.js 但在UNPKG上有着这样的URL形式： UNPKG CDN URL示例1https://unpkg.com/moment@2.22.2/min/moment.min.js 因此，你需要注意你的自定义CDN提供商的URL格式。 默认情况下，Icarus向URL模板中传入的参数采用npm的包名称和文件相对路径（例如moment@2.22.2/min/moment.min.js）。 jsDelivr和UNPKG就采用这种npm形式。 否则，如果你采用如CDN.js这样的CDN提供商，请在URL模板前加上[cdnjs]： CDN.js-style URL模板1'[cdnjs]https://some.cdn.domain.name/${package}/${version}/${filename}' Web字体CDN你可以参入Google字体镜像站的URL或是与其兼容的网络字体CDN。 Icarus依赖Ubuntu，Oxanium，和Source Code Pro这三种字体，所以确保你使用的CDN提供这些字体。 自定义的URL模板需包含字体类型type（图标icon或是字体font）和字体名称fontname两个占位符： Webfont CDN URL模板1https://some.google.font.mirror/${type}?family=${fontname} FontAwesome图标CDN你可以传入自定义的FontAwesome CDN提供商的URL。 URL中不需要包含占位符。 本主题用到了一些FontAwesome 5图标，所以自定义的提供商需要至少提供它们。 Icon Font CDN URL模板1https://custom.fontawesome.mirror/some.stylesheet.css 以上自定义配置需放到主题配置中的providers部分： _config.icarus.yml1234providers: cdn: 'https://some.cdn.domain.name/${package}/${version}/${filename}' fontcdn: 'https://some.google.font.mirror/${type}?family=${fontname}' iconcdn: 'https://custom.fontawesome.mirror/some.stylesheet.css' CDN工具函数本主题定义了三个工具函数来帮助主题开发者轻松使用自定义CDN来引用第三方的前端资源。 详情请参见ppoffice/hexo-component-inferno. 文章内容有误？请点击此处提交修改。","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9Ccdn-%E6%8F%90%E4%BE%9B%E5%95%86/"},{"title":"Icarus 用户指南｜主题配置","text":"Icarus的默认主题配置文件为_config.icarus.yml。 此文件定义了站点全局的布局与样式设置，同时也控制了例如插件与挂件等外部功能的配置。 本文详细介绍了本主题的一般配置，并且解释了Icarus使用哪些配置文件和它是如何生成并验证这些配置。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } 一般主题配置配置文件版本这个版本号与主题版本号相关却不总是相同。 Icarus使用此版本号来决定是否升级默认主题配置文件。 请不要自己更改这个版本号。 _config.icarus.yml1version: 5.0.0 主题变体通过此设置为Icarus更换”皮肤“。 此设置目前支持”default“和”cyberpunk“两种值。 你可以在此处查看Cyberpunk变体的效果。 _config.icarus.yml1variant: default Logo设置你站点的logo。 此logo会显示在导航栏和页脚。 logo配置的值既可以是你的logo图片的路径或URL地址： _config.icarus.yml1logo: /img/logo.svg 也可以像下面这样设置成文字： _config.icarus.yml12logo: text: My Beautiful Site Favicon你可以在head配置中指定你的网站favicon的路径或URL地址。 _config.icarus.yml12head: favicon: /img/favicon.svg Web App ManifestIcarus支持基本的PWAmanifest.json的生成与Meta标签。 要开启web app manifest，请再主题配置中使用如下的配置。 你也可以参考MDN来了解每个配置项的详情。 _config.icarus.yml >folded1234567891011121314151617181920212223242526272829manifest: # Web应用的名称 (默认为站点标题) name: Icaurs - Hexo Theme # Web的显示名称 # 当没有空间显示全名时显示 short_name: Icarus # Web应用的初始URL start_url: https://ppoffice.github.io/ # 应用的默认主题颜色 theme_color: &quot;#3273dc&quot; # 在应用的样式表加载之前显示的应用页默认占位背景颜色 background_color: &quot;#3273dc&quot; # 网站首选的展示模式 display: standalone # 在不同上下文下用作应用图标的图片文件 icons: - # 图片文件的路径 src: icons/touch-icon-iphone.png # 空格分割的表示图标尺寸的字符串 sizes: 144x144 # 图片的媒体类型提示 (可选) type: image/png - src: icons/touch-icon-ipad.png sizes: 152x152 - src: icon/logo.ico sizes: 72x72 96x96 128x128 256x256 Open Graph你可以在head配置中设置Open Graph。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。 请参考Hexo文档来详细了解每个配置项。 _config.icarus.yml >folded12345678910111213141516171819202122232425262728head: open_graph: # 页面标题 (og:title) (可选) title: # 页面类型 (og:type) (可选) type: blog # 页面URL地址 (og:url) (可选) url: # 页面封面图 (og:image) (可选) image: # 站点名称 (og:site_name) (可选) site_name: # 页面作者 (article:author) (可选) author: # 页面描述 (og:description) (可选) description: # Twitter卡片类型 (twitter:card) twitter_card: # Twitter ID (twitter:creator) twitter_id: # Twitter站点 (twitter:site) twitter_site: # Google+个人主页链接 (已弃用) google_plus: # Facebook admin ID fb_admins: # Facebook App ID fb_app_id: Google Structured Data你可以在head配置中设置Google Structured Data。 你应该在配置文件中将绝大部分配置留空。 仅在需要的时候在文章的front-matter中为这些设置赋值。 请参考Search for Developers来详细了解每个配置项。 _config.icarus.yml >folded12345678910111213141516head: structured_data: # 页面标题 (可选) title: # 页面描述 (可选) description: # 页面URL地址 (可选) url: # 页面作者 (article:author) (可选) author: # 页面图片 (可选) image: # 文章发布者 (可选) publisher: # 发布者Logo (可选) publisher_logo: 页面元信息你可以通过head部分的meta设置来向生成的HTML中添加自定义&lt;meta&gt;标签。 每一个meta标签应作为meta数组中的一个元素出现。 meta设置每一个元素的值应为&lt;属性名&gt;=&lt;属性值&gt;的格式，其中属性名和属性值分别代表着&lt;meta&gt;标签的属性和值。 如果&lt;meta&gt;标签有多个属性和值，请使用;来分隔&lt;属性名&gt;=&lt;属性值&gt;。 _config.icarus.yml1234head: meta: - 'name=theme-color;content=#123456' - 'name=generator;content=&quot;Hexo 4.2.0&quot;' RSS你可以通过head部分的rss设置来添加RSS链接信息。 _config.icarus.yml12head: rss: /path/to/atom.xml 导航栏navbar部分定义了导航栏中的菜单与链接。 你可以通过向menu设置项中添加&lt;链接名&gt;: &lt;链接URL&gt;的方式添加任意导航栏菜单链接。 如要向导航栏右侧添加链接，请向links设置项中添加&lt;链接名&gt;: &lt;链接URL&gt;。 _config.icarus.yml1234567891011121314navbar: # 导航栏菜单项 menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about # 导航栏右侧的链接 links: GitHub: 'https://github.com' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' 你也可以使用FontAwesome图标来作为纯文字链接的替换，格式如下： 链接格式123&lt;链接名&gt;: icon: &lt;FontAwesome图标的class名&gt; url: &lt;链接URL&gt; 页脚footer部分定义了页脚右侧的链接。 链接的配置格式与navbar中links的配置格式完全一致。 _config.icarus.yml1234567891011footer: links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus' 你也可以在页脚展示自定义版权文字： _config.icarus.yml12footer: copyright: 用💖发电 代码高亮如果你已在Hexo中启用了代码高亮功能，你可以通过article中的highlight设置来自定义代码块。 请从highlight.js/src/styles下列出的所有主题中 选择一个主题。 然后，复制文件名(不带.css后缀)到theme设置项中。 如要隐藏复制代码按钮，将clipboard设置为false。 如果你希望折叠或展开所有代码块，将fold设置为&quot;folded&quot;或&quot;unfolded&quot;。 你也可以将fold设置为空来禁止代码块折叠。 _config.icarus.yml123456789article: highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是&quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded 此外，你可以在Markdown文件中使用下面的语法来折叠单独的代码块： 123{% codeblock &quot;可选文件名&quot; lang:代码语言 &gt;folded %}...代码块内容...{% endcodeblock %} 封面 &amp; 缩略图若要为文章添加封面图，请在文章的front-matter中添加cover选项： post.md1234title: Icarus快速上手cover: /gallery/covers/cover.jpg---Post content... 类似地，你也可以在文章的front-matter中为文章设置缩略图： post.md1234title: Icarus快速上手thumbnail: /gallery/covers/thumbnail.jpg---Post content... 文章的缩略图会显示在归档页面和最新文章挂件中。 如果你在front-matter中使用的是图片的路径，你需要确保它是绝对或者相对于你的source目录的路径。 例如，为使用&lt;your blog&gt;/source/gallery/image.jpg作为缩略图，你需要在front-matter中使用/gallery/image.jpg作为图片路径。 文章阅读时间你可以将article部分的readtime设置为true来显示文章字数统计以及预计阅读时间。 _config.icarus.yml12article: readtime: true 文章更新时间若要显示文章的更新时间，请在文章的front_matter中设置updated时间： post.md1234title: Icarus快速上手updated: 2020-04-01 00:00:00---Post content... 然后，将主题配置文件的article部分的update_time设置为true： _config.icarus.yml12article: update_time: true 你也可以将update_time设置为false来隐藏所有文章的更新时间，或设置为auto而在文章的更新时间 与发布时间相同时隐藏更新时间。 文章许可协议你可以在你的文章/页面的底部展示你的作品的使用许可，许可链接可以是文字或者图标。 这里的配置与导航栏或者页脚的links配置一致： _config.icarus.yml1234567article: # 文章许可协议 licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' 'CC BY-NC-SA 4.0': 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 侧边栏设置sidebar中某个侧边栏的sticky为true来让它的位置固定而不跟随页面滚动。 _config.icarus.yml12345sidebar: left: sticky: false right: sticky: true 其他配置你可以参考Icarus用户指南来了解更多第三方的插件、挂件、以及CDN提供商的配置。 配置文件与优先级除了在_config.icarus.yml的默认主题配置文件外，Icarus也会从如下位置获取替代配置： 位于_config.yml的站点配置文件 位于_config.post.yml和_config.page.yml的布局配置文件 文章/页面的front-matter (已弃用) 位于themes/icarus/_config.yml的旧主题配置文件 (已弃用) 位于themes/icarus/_config.post.yml和themes/icarus/_config.page.yml的旧布局配置文件 布局配置文件布局配置文件遵循着与主题配置文件相同的格式和定义。 _config.post.yml中的配置对所有文章生效，而_config.page.yml中的配置对所有自定义页面生效。 这两个文件将覆盖主题配置文件中的配置。 例如，你可以在_config.post.yml中把所有文章变为两栏布局： _config.post.yml12345678910widgets: - type: recent_posts position: left - type: categories position: left - type: tags position: left 同时所有其他页面仍保持三栏布局： _config.icarus.yml12345678910widgets: - type: recent_posts position: left - type: categories position: right - type: tags position: right 文章/页面的Front-matter如果你只想要在某个文章/页面中覆盖主题配置，你可以在那个文章/页面的front-matter中写下配置。 例如，你可以像下面这样在一篇文章的front-matter中更改某篇文章的代码高亮主题： source/_post/some-post.md1234567title: 我的第一篇文章date: '2015-01-01 00:00:01'article: highlight: theme: atom-one-dark---# 文章标题 上面的配置会为那篇文章覆盖掉_config.post.yml和_config.icarus.yml中的article.highlight。 这种层次化的配置系统对于页面个性化和不同访客间的差异化优化十分有效。 比如，你可以为根据你页面目标访客的国家和语言来开启更快的CDN或本地化的评论服务。 然而需要注意的是，一些Hexo定义的文章或页面属性不会覆盖掉其他配置源中的同名配置，如 title, date, updated, comments (not comment), layout, source, photos, 和excerpt。 站点配置文件上面列出的所有配置源，包括主题配置文件，布局配置文件，和文章/页面的front-matter，会覆盖掉站点配置文件中Icarus使用到的配置。 例如，_config.icarus.yml中的title设置会覆盖掉_config.yml中的title，但new_post_name却不会，因为 Icarus没有用到这个配置项。 另外，主题配置文件中的theme_config选项会与主题配置文件中的主题配置合并并覆盖掉同名配置。 然而，我们非常不推荐使用这个配置选项。 总结总而言之，配置源的作用范围和优先级如下： 对于某个文章或页面 文章/页面的front-matter覆盖所有下面的配置源。 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章或页面 布局配置文件覆盖所有下面的配置源。 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 对于所有的文章，页面，和索引页 站点配置文件中的theme_config选项覆盖所有下面的配置源。 主题配置文件覆盖所有下面的配置源。 站点配置文件。 配置生成与校验所有的Icarus主题配置均使用YAML语言编写。 如果配置文件不存在，Icarus会通过一系列JSON Schema来自动生成默认的配置文件_config.icarus.yml。 这也是为什么你在主题目录下找不到示例配置文件(如_config.yml.example)。 大多数的JSON Schema存放在&lt;icarus_directory&gt;/include/schema目录下，而其他的则存放在 ppoffice/hexo-component-inferno仓库中。 你可以在你的hexo命令后附上--icarus-dont-generate-config来避免配置文件的自动生成。 当你每次运行hexo命令时，主题也会对比JSON Schema来校验你的配置文件。 如果校验中出现任何错误，Icarus会将错误位置与错误类型打印在屏幕上。 例如，如下的错误信息告诉我们logo配置值应该为字符串或是对象，而不是一个整型数。 你可以在你的hexo命令后附上--icarus-dont-check-config来跳过校验，但并不推荐这么做。 hexo日志1234567891011121314INFO === Checking package dependencies ===INFO === Checking the configuration file ===WARN Configuration file failed one or more checks.WARN Icarus may still run, but you will encounter unexcepted results.WARN Here is some information for you to correct the configuration file.WARN [ { keyword: 'type', dataPath: '.logo', schemaPath: '#/properties/logo/type', params: { type: 'string,object' }, message: 'should be string,object' }] 此外，如果你的默认主题配置文件不是最新版本的话，Icarus会运行迁移脚本将它升级到最新版本。 这些脚本存放在&lt;icarus_directory&gt;/include/migration目录。 你可以在你的hexo命令后附上--icarus-dont-upgrade-config来禁止配置升级。 最后，Icarus也会检查主题依赖的Node.js库是否安装并提醒你安装缺失的库。 文章内容有误？请点击此处提交修改。","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"Icarus 用户指南｜用户评论插件","text":"本文介绍Icarus 5支持的用户评论插件的安装配置。 下面的用户评论插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } 畅言安装指南 首先，登录畅言云评， 并按照PC端通用代码接入文档获取评论HTML代码。 复制appid与conf的值到主题配置的对应配置项中。 例如，如下的HTML代码： 畅言安装代码 >folded123456789&lt;!--PC版--&gt;&lt;div id=&quot;SOHUCS&quot; sid=&quot;...&quot;&gt;&lt;/div&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://cy-cdn.kuaizhan.com/upload/changyan.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.changyan.api.config({ appid: '????appid????', conf: 'prod_xxxxxxxxxxxxxxxxxxxxxxx'});&lt;/script&gt; 对应到主题配置为： _config.icarus.yml1234comment: type: changyan app_id: ????appid???? conf: prod_xxxxxxxxxxxxxxxxxxxxxxx Disqus 安装指南在线预览 首先，登录Disqus。 点击首页的“开始”(GET STARTED)按钮或者访问 此处并点击“我想要将Disqus安装到我的站点” (I want to install Disqus on my site)来创建新的站点评论服务。 在创建新站点页面中填写“网站名称”(Website Name)以及“网站类型”(Category)，然后点击“创建站点”(Create Site)。 如果你愿意的话，选择一个付费订阅。 你也可以点击左侧的“安装Disqus”(Install Disqus)来跳过此步。 下一步，选择Disqus的安装平台。 此处选择页面底部的“上面没有列出我使用的平台，使用通用代码安装” (I don’t see my platform listed, install manually with Universal Code)。 点击页面底部的“配置”(Configure)按钮跳过“通用代码安装指南”(Universal Code install instructions)。 在“配置Disqus”(Configure Disqus)页面中按需填写Disqus个性化配置。 然后，点击“完成安装”(Complete Setup)和“关闭配置”(Dismiss Setup)按钮来结束配置。 下一步，在评论服务首页的右上角点击“编辑配置”(Edit Settings)按钮。 在“为你的站点配置Disqus”(Configure Disqus for Your Site)页面上找到“Shortname”的值， 复制到主题配置的评论配置项中。 例如，下面截图中的“Shortname”为my-hexo-blog-1： 对应的主题配置为： _config.icarus.yml123comment: type: disqus shortname: my-hexo-blog-1 （可选）你可以在文章的front-matter中加入disqusId来为文章添加Disqus唯一标识。 这样，你可以在未来更改文章的位置而不会丢失所有评论。 source/_post/some-post.md12345title: 我的第一篇文章date: 2015-01-01 00:00:01disqusId: some-disqus-id---# Hello world DisqusJS在Disqus服务访问受限的地区可使用DisqusJS作为替代。 关于DisqusJS的配置过程可参考https://github.com/SukkaW/DisqusJS。 安装指南在线预览 登录Disqus并访问此链接。 点击“注册新应用”(Register new application)或者“注册应用”(registering an application)来创建新的Disqus应用。 在下一页面中填写”应用名称“(Label)，”介绍“(Description)，以及”网站地址“(Website)。 然后点击“注册我的应用”(Register my application)。 应用创建完毕后，进入应用的”设置“(Settings)界面，在”域名“(Domains)输入框中填入你Hexo站点的域名，例如ppoffice.github.io。 然后点击页面底部的“保存更改”(Save Changes)按钮。 点击当前页面中的“详情”(Details)链接切换到当前应用的主页。 从”OAuth设置“(OAuth Settings)部分中复制”API Key“到相应的主题配置项中。 例如，下面截图中的”API Key“： 对应为下面的主题配置： _config.icarus.yml12345678comment: type: disqusjs shortname: my-hexo-blog-1 api_key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxx api: https://disqus.skk.moe/disqus/ # 可选填 admin: ppoffice # 可选填 admin_label: Admin # 可选填 nesting: 4 # 可选填 如要更多了解DisqusJS和它的配置，请访问SukkaW/DisqusJS文档或 hexo-component-inferno。 Facebook 此评论插件可能会被部分广告拦截扩展拦截，请酌情使用。 安装指南在线预览 如要开启Facebook评论服务，将comment的type设置为facebook即可。 _config.icarus.yml12comment: type: facebook Giscus利用 GitHub Discussions 实现的评论系统。 安装指南在线预览 准备一个公开的 GitHub 仓库（Repository）。 访问GitHub Apps - giscus并点击”安装“(Install)。 (可选)如果你的账号下有组织账号，在下一页中选择需要安装 giscus 的用户。 在下一页面选择将 giscus 安装到”所有仓库“(All repositories)或是”选定的仓库“(Only select repositories)。 然后点击“安装”(Install)按钮。 若安装成功，网页将跳转到 giscus 官网。 你可以阅读每个的配置项的说明，并按照配置你的 giscus 安装。 完成配置后，转到页面上的”启用 giscus “(Enable giscus)并从 giscus 的 HTML 代码中复制属性值到主题配置的对应配置项中。 例如下面的 giscus 代码： giscus 安装代码 >folded12345678910111213141516&lt;script src=&quot;https://giscus.app/client.js&quot; data-repo=&quot;usr/repo&quot; data-repo-id=&quot;X_xxxxxxxxxx&quot; data-category=&quot;Announcements&quot; data-category-id=&quot;XXX_xxxxxxxxxxxxxxxx&quot; data-mapping=&quot;pathname&quot; data-strict=&quot;0&quot; data-reactions-enabled=&quot;0&quot; data-emit-metadata=&quot;0&quot; data-input-position=&quot;top&quot; data-theme=&quot;noborder_light&quot; data-lang=&quot;zh-CN&quot; data-loading=&quot;lazy&quot; crossorigin=&quot;anonymous&quot; async&gt;&lt;/script&gt; 对应下面的主题配置： _config.icarus.yml1234567891011121314comment: type: giscus repo: usr/repo # 必填项 repoId: X_xxxxxxxxxx # 必填项 category: Announcements # 可选填，默认为 Announcements categoryId: XXX_xxxxxxxxxxxxxxxx # 必填项 mapping: pathname # 可选填，默认为 pathname strict: false # 可选填 reactionsEnabled: false # 可选填 emitMetadata: false # 可选填 inputPosition: top # 可选填，默认为 top theme: noborder_light # 可选填 lang: zh-CN # 可选填，默认为 en lazy: true # 可选填，默认为 false Gitalk 安装指南在线预览 登录GitHub并点此注册一个新的OAuth应用。 填写”应用名称“(Application name)，”应用主页“(Homepage URL)，”应用描述“(Application description)。 然后，在”认证回调地址“(Authorization callback URL)填写你的博客的根URL地址。 点击“注册应用”(Register application)按钮来跳转到应用详情界面。 复制”Client ID“与”Client Secret“的值并填入主题配置的相应配置项中。 例如，对于下面的”Client ID“和”Client Secret“： GitHub OAuth应用1234Client IDxxxxxxxxxxxxxxxxxxxxClient Secretxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 对应如下的Gitalk的配置： _config.icarus.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 language: zh-CN # 可选填 关于上述配置的含义和可选值，请参考Gitalk文档或 hexo-component-inferno。 Gitment Gitment似乎已停止维护。你可以选择Gitalk或utterances作为基于GitHub Issues的评论系统的替代。 安装指南 参照Gitalk中的步骤注册GitHub OAuth应用。 复制”Client ID“与”Client Secret“的值到主题配置的相应配置项中。 下面是Gitment的示例配置： _config.icarus.yml123456789comment: type: gitment owner: you_github_name repo: Some-of-Your-GitHub-Repo client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx theme: gitment.defaultTheme # 可选填 per_page: 20 # 可选填 max_comment_height: 250 # 可选填 关于上述配置的含义，请参考Gitment文档或 hexo-component-inferno。 Isso如果你希望自己搭建一个评论系统而不是依赖第三方的评论服务时，Isso是一个可行的选择。 然而，不同于第三方评论系统，你需要准备一个Web服务器用来运行Isso服务端程序。 安装指南 请参照Isso文档安装并启动Isso服务器。 将Isso服务器的HTTP URL填入到主题配置的相应配置项中。 例如，如果你的Isso服务地址为https://posativ.org/isso/api/，你会有如下的评论配置： _config.icarus.yml123comment: type: isso url: posativ.org/isso/api LiveRe 此评论插件可能会被部分广告拦截扩展拦截，请酌情使用。 安装指南 首先，登录LiveRe。 点击导航栏上的“安装”(Install)链接，进入安装界面。 选择免费”City“选项下方的“现在安装”(Install Now)按钮。 在”获取LiveRe City代码“(Get LiveRe City code)页面填写”站点地址“(Site URL)，”网站名称“(Name of website)， 和”网站类别“(Choose site category)。 勾选“同意广告协议”(I have check the advertising terms…)并点击”获取代码“(Get code)按钮来跳转到LiveRe HTML代码页面。 复制data-uid=&quot;...&quot;引号内的值到主题配置中的相应配置项中。 例如，下方的LiveRe代码： LiveRe安装代码 >folded123456789101112131415161718&lt;!-- LiveRe City install code --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;ABCD1234O0OxxxxXXXX000==&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script'); &lt;/script&gt;&lt;noscript&gt; Please activate JavaScript for write a comment in LiveRe&lt;/noscript&gt;&lt;/div&gt;&lt;!-- completed City install code --&gt; 对应的主题配置为： _config.icarus.yml123comment: type: livere uid: ABCD1234O0OxxxxXXXX000== TwikooTwikoo是一个基于云函数的自建评论系统。 不同于其他第三方评论服务，在Icarus中设置和使用Twikoo之前，你需要将它的后端部署到云环境上。 安装指南在线预览 按照Twikoo文档，将Twikoo云函数部署到你指定的云服务商之上。 将你部署的env_id填入主题设置中的对应设置项之中。 _config.icarus.yml12345comment: type: twikoo env_id: xxxxxxxx region: ap-guangzhou # 可选填 lang: zh-CN # 可选填 utterances 安装指南在线预览 准备一个公开的GitHub仓库(Repository)。 访问GitHub Apps - utterances并点击”安装“(Install)。 (可选)如果你的账号下有组织账号，在下一页中选择需要安装utterances的用户。 在下一页面选择将utterances安装到”所有仓库“(All repositories)或是”选定的仓库“(Only select repositories)。 然后点击“安装”(Install)按钮。 若安装成功，网页将跳转到utterances官网。 你可以阅读每个的配置项的说明，并按照配置你的utterances安装。 完成配置后，转到页面上的”开启utterances“(Enable Utterances)并从utterances的HTML代码中复制属性值到主题配置的对应配置项中。 例如下面的utterances代码： utterances安装代码 >folded1234567&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;Your-GitHub-Username/Your-Public-Repo-Name&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async&gt;&lt;/script&gt; 对应下面的主题配置： _config.icarus.yml1234567comment: type: utterances repo: Your-GitHub-Username/Your-Public-Repo-Name issue_term: pathname # 必填项，与issue_number二选一填写 issue_number: 100 # 必填项，与issue_term二选一填写，每篇文章对应一个issue，填写前需要手动创建issue label: some-issue-label # 可选填 theme: github-light # 可选填 Valine 安装指南在线预览 有用户发现一个存在于Valine评论插件的漏洞会导致此评论服务暴露所有评论者的 IP地址 (xCss/Valine#336)。 请在此漏洞修复之前换用其他评论服务。 按照快速开始文档创建LeanCloud应用。 将你LeanCloud应用的”App ID“和”App Key“复制到主题配置的对应配置项中。 此外，你可以参考配置项来了解可选配置项的详情和可能的配置值。 下面是示例配置： _config.icarus.yml123456789101112131415161718comment: type: valine app_id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx app_key: xxxxxxxxxxxxxxxxxxxxxx placeholder: &quot;&quot; # 可选填 avatar: mm # 可选填 avatar_force: false # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 page_size: 10 # 可选填 lang: zh-CN # 可选填 visitor: false # 可选填 highlight: true # 可选填 record_ip: false # 可选填 server_urls: # 可选填 emoji_cdn: # 可选填 emoji_maps: # 可选填 enable_qq: false # 可选填 required_fields: [] # 可选填 Waline 安装指南在线预览 按照快速上手创建LeanCloud应用和Vercel项目。 将你Vercel项目的”服务器地址“(Server URL)复制到主题配置的对应配置项中。 通常它类似于https://your-domain.vercel.app。 此外，你可以参考前端配置来了解可选配置项的详情和可能的配置值。 下面是示例配置： _config.icarus.yml12345678910111213141516171819202122comment: type: waline server_url: https://your-domain.vercel.app path: window.location.pathname # 可选填 lang: zh-CN # 可选填 locale: # 可选填 placeholder: 'Comment here...' emoji: # 可选填 - '//unpkg.com/@waline/emojis@1.0.1/weibo' dark: auto # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 required_meta: [] # 可选填 login: enable # 可选填 word_limit: 0 # 可选填 page_size: 10 # 可选填 image_uploader: false # 可选填 highlighter: true # 可选填 tex_renderer: false # 可选填 search: false # 可选填 pageview: false # 可选填 comment: false # 可选填 copyright: true # 可选填 文章内容有误？请点击此处提交修改。","link":"/Plugins/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E7%94%A8%E6%88%B7%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/"},{"title":"Icarus 用户指南｜赞赏按钮","text":"本文介绍Icarus 5支持的赞赏按钮的安装配置。 若需同时展示多个按钮，只需像如下这样在主题配置的donates数组中添加多个按钮配置： _config.icarus.yml1234567donates: - type: ... # 按钮1 ... - type: ... # 按钮2 ... 下面的赞赏按钮由ppoffice/hexo-component-inferno提供，完整的支持按钮列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } 爱发电安装指南 注册爱发电并复制个人页面的地址。 将如下配置添加到主题配置中： _config.icarus.yml12345donates: - type: afdian # 个人赞助页面的地址 url: /path/to/afdian/personal/page 支付宝安装指南 登录支付宝并导出个人支付二维码图片。 将二维码图片保存到你的Hexo网站的附件文件夹下，或将它上传至图床。 向主题配置中添加如下配置： _config.icarus.yml12345donates: - type: alipay # 支付宝二维码图片地址 qrcode: /path/to/alipay/qrcode.png Buy me a Coffee安装指南 注册Buy me a Coffee并复制个人页面的地址。 将如下配置添加到主题配置中： _config.icarus.yml12345donates: - type: buymeacoffee # 个人赞助页面的地址 url: /path/to/buymeacoffee/personal/page Paypal安装指南 登录Paypal，点击此处来创建一个Paypal捐赠按钮。 在“选择按钮样式”(Choose button style)页面选择“国家/地区”(Country/Region)和“语言”(Language)，点击“继续”(Continue) 进入下一页面。 在“添加机构详情”(Add organization details)页面中，选择“使用账号ID”(Use account ID)或“使用Email地址”(Use email address) 作为唯一账号标识符。 然后点击“继续”(Continue)进入下一页面。 在“设置捐赠数额”(Set donation amounts)页面选择“接收的货币种类”(Currency you’ll receive donations in)，捐赠数额选择 “任意数额”(Any amount)。 此捐赠按钮暂不支持“指定数额”的捐赠选项。 点击“结束并获取代码”(Finish and Get Code)按钮进入下一页面。 从“按钮HTML代码”(Button HTML)页面中复制business和currency_code两项的值。 将它们填写到主题配置的business和currency_code设置中。 例如，下方的Paypal捐赠按钮代码： Paypal按钮HTML代码123456&lt;form action=&quot;https://www.paypal.com/cgi-bin/webscr&quot; ...&gt;&lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_donations&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;business&quot; value=&quot;XXXXXXXXXXXXX&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;currency_code&quot; value=&quot;USD&quot; /&gt;...&lt;/form&gt; 对应的主题配置为: _config.icarus.yml12345donates: - type: paypal business: XXXXXXXXXXXXX currency_code: USD Patreon安装指南 注册Patreon并复制个人页面的URL地址。 将如下配置添加到主题配置中： _config.icarus.yml12345donate: - type: patreon # 个人赞助页面的地址 url: /path/to/patreon/personal/page 微信安装指南 登录微信并导出个人支付二维码图片。 将二维码图片保存到你的Hexo网站的附件文件夹下，或将它上传至图床。 向主题配置中添加如下配置： _config.icarus.yml12345donates: - type: wechat # 微信二维码图片地址 qrcode: /path/to/wechat/qrcode.png 文章内容有误？请点击此处提交修改。","link":"/Plugins/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E8%B5%9E%E8%B5%8F%E6%8C%89%E9%92%AE/"},{"title":"Icarus 用户指南｜其他插件","text":"本文介绍Icarus 5支持的其他插件的安装配置。 下面的插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 画廊安装指南 Icarus的画廊插件同时包含了lightGallery与 Justified Gallery两种插件。 若要启用画廊插件，请将主题配置中plugins &gt; gallery的值设置为true。 _config.icarus.yml12plugins: gallery: true 此外，若要使用Justified Gallery，请将你的图片包裹在&lt;div class=&quot;justified-gallery&quot;&gt;与&lt;/div&gt;的HTML标签对中。 并且如果你使用的是Markdown语法来引用图片的话，请在HTML标签和Markdown之间添加空行。 例如，下方画廊预览的Markdown代码为： Justified-Gallery-Markdown.md >folded12345678910&lt;div class=&quot;justified-gallery&quot;&gt;![Elephant](/hexo-theme-icarus/gallery/animals/elephant.jpeg)![Dog](/hexo-theme-icarus/gallery/animals/dog.jpeg)![Birds](/hexo-theme-icarus/gallery/animals/birds.jpeg)![Fox](/hexo-theme-icarus/gallery/animals/fox.jpeg)![Horse](/hexo-theme-icarus/gallery/animals/horse.jpeg)![Leopard](/hexo-theme-icarus/gallery/animals/leopard.jpeg)&lt;/div&gt; 同样，我们也可使用纯HTML来创建Justified Gallery。 这种情况下HTML标签之间就不需要添加空行了： Justified-Gallery-HTML.md >folded12345678&lt;div class=&quot;justified-gallery&quot;&gt;&lt;img src=&quot;/hexo-theme-icarus/gallery/animals/elephant.jpeg&quot; alt=&quot;Elephant&quot; /&gt;&lt;img src=&quot;/hexo-theme-icarus/gallery/animals/dog.jpeg&quot; alt=&quot;Dog&quot; /&gt;&lt;img src=&quot;/hexo-theme-icarus/gallery/animals/birds.jpeg&quot; alt=&quot;Birds&quot; /&gt;&lt;img src=&quot;/hexo-theme-icarus/gallery/animals/fox.jpeg&quot; alt=&quot;Fox&quot; /&gt;&lt;img src=&quot;/hexo-theme-icarus/gallery/animals/horse.jpeg&quot; alt=&quot;Horse&quot; /&gt;&lt;img src=&quot;/hexo-theme-icarus/gallery/animals/leopard.jpeg&quot; alt=&quot;Leopard&quot; /&gt;&lt;/div&gt; 效果预览 下面是Justified Gallery实现的图片网格。 你也可以点击其中的任意图片查看lightGallery的全图展示效果。 下面的图片来源于pexel.com KaTeX安装指南 你可以使用KaTeX插件来渲染\\(\\TeX\\)数学公式。 若要启用KaTeX插件，请将主题配置中plugins &gt; katex的值设置为true。 _config.icarus.yml12plugins: katex: true 请使用\\\\(和\\\\)包裹你的行内公式，使用$$或\\\\[与\\\\]标签对包裹块状公式。 例如： Some-Post.md >folded123456789这是一个行内公式：\\\\(ax^2+bx+c=0\\\\)。这是一个块状公式：$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$这是另一个块状公式：\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\] 有时你的\\(\\TeX\\)语法会被错认为Markdown语法而导致公式渲染异常。 例如，下面的公式不会渲染成功，因为其中包含多个_(下划线)而被Markdown渲染器错误的认成Markdown的斜体字语法： Some-Post.md123$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$ 在这种情况下，你可以选择转义每个可能导致歧义的字符： Some-Post.md123$$\\hat{x}\\_{k}=\\hat{x}\\_{k}^{-}+K\\_{t}\\left(y\\_{k}\\right)$$ 或是简单地将整个公式用一个额外的HTML标签对包裹起来： Some-Post.md12345&lt;div&gt;$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$&lt;/div&gt; MathJax安装指南 你可以使用MathJax插件来渲染\\(\\TeX\\)，MathML，或AsciiMath数学公式。 若要启用MathJax插件，请将主题配置中plugins &gt; mathjax的值设置为true。 _config.icarus.yml12plugins: mathjax: true 当使用\\(\\TeX\\)语法时，请使用$或\\\\(与\\\\)包裹行内公式，$$或\\\\[与\\\\]标签对包裹块状公式。 或者使用\\(\\LaTeX\\)环境。例如： Tex-Example.md >folded123456789101112131415161718这是一个行内公式：\\\\(ax^2+bx+c=0\\\\)。这是另一个行内公式：$ax^2+bx+c&gt;0$。这是一个块状公式：$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$这是另一个块状公式：\\\\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\\\]或者使用\\\\(\\LaTeX\\\\)环境：\\\\begin{equation}A =\\\\begin{bmatrix} a &amp; b \\\\\\\\ c &amp; c\\\\end{bmatrix}\\\\end{equation} 或者直接使用MathML语法。例如： MathML-Example.md >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950当&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;mo&gt;≠&lt;/mo&gt; &lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;，方程&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;msup&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;/msup&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;mi&gt;c&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt; 有两个解，它们是&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt; &lt;mi&gt;x&lt;/mi&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mrow&gt; &lt;mfrac&gt; &lt;mrow&gt; &lt;mo&gt;-&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mo&gt;±&lt;/mo&gt; &lt;msqrt&gt; &lt;msup&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;/msup&gt; &lt;mo&gt;-&lt;/mo&gt; &lt;mn&gt;4&lt;/mn&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;mi&gt;c&lt;/mi&gt; &lt;/msqrt&gt; &lt;/mrow&gt; &lt;mrow&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;/mrow&gt; &lt;/mfrac&gt; &lt;/mrow&gt; &lt;mtext&gt;.&lt;/mtext&gt;&lt;/math&gt; 同样地，你也可以使用MathJax支持的AsciiMath。 公式需包裹在\\`内。 AsciiMath-Example.md >folded1当\\`a != 0\\`，方程\\`ax^2 + bx + c = 0\\`有两个解，它们是&lt;p style=&quot;text-align:center&quot;&gt;\\`x = (-b +- sqrt(b^2-4ac))/(2a)\\`.&lt;/p&gt; 有时你的\\(\\TeX\\)语法会被错认为Markdown语法而导致公式渲染异常。 请参照KaTeX一节来查看解决方案。 效果预览(\\(\\TeX\\) &amp; \\(\\LaTeX\\)) 这是一个行内公式：\\(ax^2+bx+c=0\\)。这是另一个行内公式：$ax^2+bx+c&gt;0$。 这是一个块状公式： $$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ 这是另一个块状公式： \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)e^{2 \\pi i \\xi x}d\\xi\\] 或者使用\\(\\LaTeX\\)环境： \\begin{equation} A = \\begin{bmatrix} a &amp; b \\\\ c &amp; c \\end{bmatrix} \\end{equation} 效果预览(MathML) 当 a ≠ 0 ， 方程 a x 2 + b x + c = 0 有两个解，它们是 x = - b ± b 2 - 4 a c 2 a . 效果预览(AsciiMath) 当`a != 0`，方程`ax^2 + bx + c = 0`有两个解，它们是`x = (-b +- sqrt(b^2-4ac))/(2a)`. Cookie同意提示安装指南 你可以通过启用Cookie同意提示插件来向你的访客展示Cookie同意对话框。 请参考下载Cookie Consent和Cookie Consent插件文档来了解每个配置项的细节。 你也可以通过注释掉配置的方式来禁用Cookie同意对话框。 _config.icarus.yml123456789101112plugins: cookie_consent: # 同意对话框类型。可以为&quot;info&quot;，&quot;opt-in&quot;，或&quot;opt-out&quot; type: info # 弹出框主题。可以为&quot;block&quot;，&quot;edgeless&quot;，或&quot;classic&quot; theme: edgeless # 是否使弹出框固定，不随页面滚动而滚动 static: false # 弹出框在屏幕上的位置 position: bottom-left # 你网站的Cookie协议的URL policyLink: 'https://www.cookiesandyou.com/' 浏览器升级提醒 (Outdated Browser)安装指南 你可以使用浏览器升级提醒(Outdated Browser)插件来检测你的网站访客使用的老旧浏览器，并提醒他们升级浏览器。 若要启用此插件，请将主题配置中plugins &gt; outdated_browser的值设置为true。 点击此处即可预览插件开启效果。 _config.icarus.yml12plugins: outdated_browser: true 网页载入动画安装指南 Icarus默认启用网页载入动画。 若需禁止载入动画，请在你的主题配置中将plugins &gt; animejs设置为false。 _config.icarus.yml12plugins: animejs: false 另外，若需禁用网页载入进度条，请在你的主题配置中将plugins &gt; progressbar设置为false。 _config.icarus.yml12plugins: progressbar: false 文章内容有误？请点击此处提交修改。","link":"/Plugins/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6/"},{"title":"Icarus 用户指南｜快速上手","text":"欢迎使用Icarus！ Icarus是静态网站生成器Hexo的一款简单，精致，而现代的主题。 它力求设计上的优雅，但也不抛弃使用上的简单明了。 它灵活且多功能的配置系统让资深用户也能极尽细节地装饰他们的站点。 Icarus同时也提供了超多插件与挂件来满足你的多元的站点个性化和优化需求。 除此以外，它的崭新实现使得更好的IDE支持和第三方接入成为可能，并提供了更多未来的优化空间。 在你继续安装Icarus之前，请先花些时间阅览Hexo文档。 如要安装Icarus，你可以选择如下两种方式中的任意一种： 从源码安装 使用NPM安装 从GitHub的仓库中下载源码的压缩包并解压到你Hexo站点的主题目录中。 或者，你可以使用Git来克隆Icarus的代码仓库到themes目录下： Git Bash/命令行1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 你可以省略-b &lt;version number&gt;来获取Icarus的最新开发版本。 如果你想同时下载Git仓库的完整提交历史，请同时省略--depth 1。 另外，你也可以使用下面的命令将Icarus安装为Git子模块(submodule)： Git Bash/命令行1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 若要使用NPM将Icarus安装为Node包，在你的Hexo站点根目录运行如下命令： 命令行1npm install -S hexo-theme-icarus hexo-renderer-inferno 接下来，在你的站点的_config.yml文件中的开启Icarus： _config.yml1theme: icarus 或使用hexo命令修改主题为Icarus: 命令行1hexo config theme icarus 最后，使用如下命令来启动Hexo本地测试服务器并开始创作。 命令行1hexo server 如需了解更多主题、挂件、和插件相关的信息，请查看 Icarus用户指南。 你也可以参考本站的源代码来获取更多的使用示例。 本站源代码位于GitHub上Icarus代码仓库的site分支。 此外，你也可能在GitHub讨论组上获得其他Icarus用户的帮助。 额外资源 下面是一些帮助你进一步个性化你的站点的其他资源。 你也可以点击此处来提交你的Icarus教程。 Hexo中文文档 博客源码分享 by 辣椒の酱 hexo-theme-icarus 3 食用经验分享 by iMaeGoo 活用 Bulma 美化 Icarus 文章 by iMaeGoo icarus主题自定义 by kuzen Icarus4主题自定义记录 by BlakeNeko Icarus 主题自定义 by AlphaLxy 文章内容有误？点击此处提交修改。 unsplash-logo王希孟 千里江山图卷","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"title":"Icarus 用户指南｜站内搜索插件","text":"本文介绍Icarus 5支持的站内搜索插件的安装配置。 下面的站内搜索插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } Algolia 安装指南 在线预览 在Hexo站点的根目录安装hexo-algolia插件。 注册并登录Algolia。 首次登录控制面板(Dashboard)时点击页面上的“创建索引”(Create Index)按钮。 然后，输入”索引名称“(Index name)并点击“创建”(Create)完成索引创建。 下一步，点击右侧导航栏上的”API密钥“(API Keys)，复制页面上的“应用ID”(Application ID)和“仅限搜索的API Key” (Search-Only API Key)。 打开Hexo站点根目录下的站点配置文件_config.yml，填入上面复制的信息到hexo-algolia插件的配置中。 例如，下面的Algolia索引信息： Algolia索引信息123Algolia索引名称: My-Hexo-SiteApplication ID: ABCDEFGHIJKLSearch-Only API Key: 7b08fca7d42412cee901a25643124221 对应的站点配置为： _config.yml1234algolia: applicationID: My-Hexo-Site indexName: ABCDEFGHIJKL apiKey: 7b08fca7d42412cee901a25643124221 回到Algolia控制面板的”API密钥“(API Keys)页面并切换到“所有API Keys”(All API Keys)标签页。 点击“新建API Key”(New API Key)按钮。 在弹出的“创建API Key”(Create API Key)对话框中，在”索引“(Indices)处选择你在上一步中创建的“索引”(Indices)。 然后，“ACL”项中添加addObject，deleteObject，listIndexes， deleteIndex。 点击“创建”(Create)完成密钥的创建。 复制刚刚创建的API Key，例如727fbd8c998fe419318fa350db6793ca。 打开一个Windows命令行(CMD)或Linux/macOS终端并切换当前目录到你的Hexo站点的根目录。 设置环境变量HEXO_ALGOLIA_INDEXING_KEY为上一步中创建的API Key。 hexo-algolia插件上传网站索引时会用到这个变量。 Windows下： Windows命令行(CMD)12C:\\Users\\you&gt; cd path/to/your/hexo/siteC:\\Users\\you&gt; set HEXO_ALGOLIA_INDEXING_KEY=727fbd8c998fe419318fa350db6793ca Linux/macOS下： Linux/macOS终端12$ cd path/to/your/hexo/site$ export HEXO_ALGOLIA_INDEXING_KEY=&quot;727fbd8c998fe419318fa350db6793ca&quot; 然后，运行下面的命令来清理站点并上传网站索引到Algolia： Windows命令行(CMD)或Linux/macOS终端12$ hexo clean$ hexo algolia 最后，在主题配置中设置搜索引擎为Algolia： _config.icarus.yml12search: type: algolia 百度搜索安装指南 打开主题配置文件并设置搜索为百度搜索： _config.icarus.yml12search: type: baidu 谷歌自定义搜索 安装指南 在线预览 登录你的谷歌账户并访问Google CSE来创建自定义搜索。 在“需要搜索的站点”(Sites to Search)中填入你的Hexo站点域名。 在“语言”(Language)选择框中选择正确的语言。 然后填写自定义“搜索引擎名称”(Name of the search engine)。 点击“创建”(Create)按钮完成引擎的创建。 然后，点击页面上的“添加到你的站点”(Add it to your site)右侧的“获取代码”(Get code)按钮。 从HTML代码中复制cx的值填入到对应主题配置项中。 例如，下面的HTML代码： Google CSE HTML代码12&lt;script async src=&quot;https://cse.google.com/cse.js?cx=012345601234560123456:abcdefghijklmn&quot;&gt;&lt;/script&gt;&lt;div class=&quot;gcse-search&quot;&gt;&lt;/div&gt; 对应下面的主题配置： _config.icarus.yml123search: type: google_cse cx: 012345601234560123456:abcdefghijklmn Insight安装指南 Insight为本站默认的站内搜索引擎。 你可以通过下面的主题配置来启用它： _config.icarus.yml123search: type: insight include_pages: true # 可选项。设置为false时从搜索结果中排除所有page 文章内容有误？请点击此处提交修改。","link":"/Plugins/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/"},{"title":"Icarus 用户指南｜升级指南","text":"从5.x升级至6.x 将Node.js升级到14.0或者更新的版本。 下载源代码或者从NPM安装Icarus 6.x。 你可以在Icarus 用户指南｜快速上手中找到安装指导。 如果你打算通过修改源代码的方式自定义主题，你必须从源代码安装主题。 运行hexo clean来清理缓存并让Icarus为你升级主题配置文件。 阅读更新说明和最新文档来了解更多新功能的信息。 从4.x升级至5.x 将Node.js升级到12.4.0或者更新的版本。 下载源代码或者从NPM安装Icarus 5.x。 你可以在Icarus 用户指南｜快速上手中找到安装指导。 如果你打算通过修改源代码的方式自定义主题，你必须从源代码安装主题。 运行hexo clean来清理缓存并让Icarus为你升级主题配置文件。 阅读更新说明和最新文档来了解更多新功能的信息。 从3.x升级至4.x 将Node.js升级到10.13.0或者更新的版本。 下载源代码或者从NPM安装Icarus 4.x。 你可以在Icarus 用户指南｜快速上手中找到安装指导。 如果你打算通过修改源代码的方式自定义主题，你必须从源代码安装主题。 运行hexo clean来清理缓存。 按照Icarus的提示安装缺失的依赖软件包： 命令行123456$ hexo clean...ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save hexo@^5.0.2 hexo-component-inferno@^0.8.2 hexo-log@^2.0.0 hexo-util@^2.2.0ERROR or:ERROR yarn add hexo@^5.0.2 hexo-component-inferno@^0.8.2 hexo-log@^2.0.0 hexo-util@^2.2.0 再次运行hexo clean来让Icarus为你升级主题配置文件。 Icarus会备份并删除themes/icarus/_config.yml文件，然后创建_config.icarus.yml作为新的主题配置文件。 你可以参考_config.icarus.yml.example来了解示例配置. 命令行123456789$ hexo clean...WARN Your theme configuration is outdated (3.0.0 &lt; 4.0.0).INFO To skip the configuration upgrade, use &quot;--icarus-dont-upgrade-config&quot;.INFO Backing up theme configuration files...INFO themes/icarus/_config.yml =&gt; themes/icarus/_config.yml.dc00f8b8f8bc03ede351d711e958dc4bINFO Upgrading theme configurations...INFO Theme configurations are written to /tmp/_config.icarus.yml.INFO Example configurations is at /tmp/_config.icarus.yml.example. Icarus现在将文章的缩略图和封面图区别对待。 对于有缩略图的所有文章/页面，将其front-matter中的thumbnail:更改为cover:。 post.md12345 title: Icarus快速上手 date: 2020-04-01- thumbnail: /gallery/covers/vector_landscape_1.svg+ cover: /gallery/covers/vector_landscape_1.svg--- 你仍可以在front-matter中设置thumbnail来在文章归档页面以及最新文章挂件中显示小一点的缩略图。 阅读更新说明和最新文档来了解更多新功能的信息.","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/"},{"title":"Icarus 用户指南｜自定义 Hexo 标签插件","text":"除了Icarus 用户指南｜Hexo 内置标签指南中描述的Hexo原生支持的标签插件以外，Icarus也提供其他 几个用来定制内容显示的有用的标签插件。 下面的标签插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 .example-tab-container { margin: 0 0 20px 0; padding: 10px 20px 20px 20px; border-radius: 6px; box-shadow: 0 0.5em 0.75em -0.125em rgba(10,10,10,0.1), 0 0px 0 1px rgba(10,10,10,0.02); } 消息五颜六色的消息块可以用来强调你文章中的部分文本。 它的语法定义如下： 123{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %} &lt;内容&gt;{% endmessage %} color此选项定义消息块的颜色。 其为可选项。 它可用的配置值与示例如下： default 一个没有设置颜色的代码块。 dark 一个深色(dark)的代码块。 primary 一个主题色(primary)的代码块。 info 一个提示色(info)的代码块。 success 一个成功色(success)的代码块。 warning 一个警示色(warning)的代码块。 danger 一个危险色(danger)的代码块。 size此选项定义消息块的大小。 其为可选项。 它可用的配置值与示例如下： small 一个小(small)的代码块。 default 一个没有设置大小的代码块。 medium 一个中等大小(small)的代码块。 large 一个大(small)的代码块。 icon此选项定义显示在消息块头部的图标。 其为可选项。 它的值应为FontAwesome的图标class name。 如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。 一个有着GitHub图标的消息块 一个有着GitHub图标(&quot;icon:fa-brands fa-github&quot;)的消息块。 一个有着Node.js图标的消息块 一个有着Node.js图标(&quot;icon:fa-brands fa-node-js&quot;)的消息块。 一个有着NPM图标的消息块 一个有着NPM图标(&quot;icon:fa-brands fa-npm&quot;)的消息块。 title此选项定义消息块的标题。 其为可选项。 如果标题含有空格，则配置名与配置值需要用引号包裹住。 有标题的消息块 有标题的消息块(&quot;title:有标题的消息块&quot;)。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 没有标题的消息块。 标签页标签页是一个功能强大的用于展示平行内容的标签插件。 同一时间内，只有活动的标签页内容才能展示给用户。 它的语法定义如下： 123456789{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %} 标签容器一个标签容器有着以下选项： size此选项定义标签页的大小。 其为可选项。 它可用的配置值与示例如下： 第一页 第二页 这是一个小(small)标签页容器的第一页。 这是一个小(small)标签页容器的第二页。 第一页 第二页 这是一个没有指定大小的标签页容器的第一页。 这是一个没有指定大小的标签页容器的第二页。 第一页 第二页 这是一个中等大小(medium)标签页容器的第一页。 这是一个中等大小(medium)标签页容器的第一页。 第一页 第二页 这是一个大(large)标签页容器的第一页。 这是一个大(large)标签页容器的第二页。 align此选项定义标签页按钮的对齐方式。 其为可选项。 它可用的配置值与示例如下： 第一页 第二页 这是一个没有指定对齐方式的标签页容器的第一页。 这是一个没有指定对齐方式的标签页容器的第二页。 第一页 第二页 这是一个居中对齐的(centered)标签页容器的第一页。 这是一个居中对齐的(centered)标签页容器的第二页。 第一页 第二页 这是一个右对齐的(right)标签页容器的第一页。 这是一个右对齐的(right)标签页容器的第二页。 第一页 第二页 这是一个全宽的(fullwidth)标签页容器的第一页。 这是一个全宽的(fullwidth)标签页容器的第二页。 style此选项定义标签页按钮的样式。 其为可选项。 此外你可以将样式与全宽(fullwidth)对齐方式结合。 它可用的配置值与示例如下： 第一页 第二页 这是一个盒状(boxed)标签页容器的第一页。 这是一个盒状(boxed)标签页容器的第二页。 第一页 第二页 这是一个拨动开关状(toggle)标签页容器的第一页。 这是一个拨动开关状(toggle)标签页容器的第二页。 第一页 第二页 这是一个圆角拨动开关状(toggle-rounded)标签页容器的第一页。 这是一个圆角拨动开关状(toggle-rounded)标签页容器的第二页。 第一页 第二页 这是一个全宽(fullwidth)盒状(boxed)标签页容器的第一页。 这是一个全宽(fullwidth)盒状(boxed)标签页容器的第二页。 第一页 第二页 这是一个全宽(fullwidth)拨动开关状(toggle)标签页容器的第一页。 这是一个全宽(fullwidth)拨动开关状(toggle)标签页容器的第二页。 第一页 第二页 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第一页。 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第二页。 Tab一个标签页有如下选项： id此选项为标签页元素的独特标识符(ID)。 此项为必填项。 一个标签页ID应当在整个页面内为独一无二的，这样Icarus才能定位、显示、和隐藏正确的标签页内容。 active此选项标记当前的标签页是否默认显示。 此项为选填项。 同一时刻一个标签组中只有一个标签页可以标记为活动(active)标签页。 icon此选项定义标签按钮中显示的图标。 此项为选填项。 它的值应为FontAwesome图标的class name。 如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。 GitHub Node.js 这个标签页的图标(icon)为&quot;icon:fa-brands fa-github&quot;。 这个标签页的图标(icon)为&quot;icon:fa-brands fa-node-js&quot;。 GitHub Node.js 这个标签页的图标(icon)为&quot;icon:fa-brands fa-github&quot;。 这个标签页的图标(icon)为&quot;icon:fa-brands fa-node-js&quot;。 title此选项定义标签按钮的标题。 其为可选项。 如果标题含有空格，则配置名与配置值需要用引号包裹住。 有标题的标签页 另一个有标题的标签页 这个标签页的标题(title)为(&quot;title:有标题的标签页&quot;)。 这个标签页的标题(title)为(&quot;title:另一个有标题的标签页&quot;)。","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89-hexo-%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/"},{"title":"Icarus 用户指南｜网站分析插件","text":"本文介绍Icarus 5支持的网站统计与分析插件的安装配置。 下面的网站统计与分析插件由ppoffice/hexo-component-inferno提供，完整的支持插件列表和配置详情以其为准。 本文中涉及的所有插件均可能被部分广告拦截浏览器扩展拦截，请酌情使用。 百度统计安装指南 登录百度统计。 在“管理 &gt; 网站列表”页面上点击“新增网站”按钮并填写“网站域名”，“网站首页”等站点信息。 点击“确定”完成站点创建。 在下一页面上找到hm.baidu.com/hm.js?后的ID并填写到主题配置的plugins &gt; baidu_analytics &gt; tracking_id值中。 例如，如下的统计代码： 百度统计代码123456789&lt;script&gt;var _hmt = _hmt || [];(function() {var hm = document.createElement(&quot;script&quot;);hm.src = &quot;https://hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea&quot;;var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; 对应的主题配置为： _config.icarus.yml123plugins: baidu_analytics: tracking_id: 3f06f2b732a5b1034c989f74e28d0eea Bing Webmaster Tools安装指南 登录Bing - Webmaster Tools. 然后，选择“手动添加网站”(Add your site manually)并输入你网站的URL。 点击“添加”(Add)继续。 在“添加并验证网站”(Add &amp; verify site)面板，选择“HTML Meta 标记”(HTML Meta Tag)方法。 复制HTML meta标签中content属性的值到主题配置中的plugins &gt; bing_webmaster &gt; tracking_id下。 _config.icarus.yml123plugins: bing_webmaster: tracking_id: ABCDEFABCDEFABCDEFABCDEFABCDEFABCDEF 不蒜子网页计数器安装指南 将plugins &gt; busuanzi设置为true来开启不蒜子访客计数器并在网页尾部和每篇博文的头部展示访问次数。 _config.icarus.yml12plugins: busuanzi: true CNZZ统计安装指南 登录友盟+。 在友盟+工作台首页点击“创建新应用” &gt; “Web应用”。 然后输入“网站名称”，“网站域名”，“网站首页”等站点信息信息。 完成后点击“确认添加站点”。 在获取统计代码界面找到“文字样式”一栏下的HTML代码。 分别将其中id与web_id的值复制到主题配置的plugins &gt; cnzz &gt; id和web_id中。 例如，如下的统计安装代码： CNZZ统计代码1&lt;script type=&quot;text/javascript&quot; src=&quot;https://s9.cnzz.com/z_stat.php?id=123456789000&amp;web_id=123456789000&quot;&gt;&lt;/script&gt; 对应的主题配置为： _config.icarus.yml1234plugins: cnzz: id: 123456789000 web_id: 123456789000 Google Analytics安装指南 登录Google Analytics并点击左侧的”管理“(Admin)进入管理界面。 在管理界面上点击”创建资产“(Create Property)按钮，选择“测量的应用类型”(What do you want to measure?)为Web。 然后点击”继续“(Continue)按钮。 然后，填写“网站名称”(Website Name)，“URL地址”(Website URL)，“行业分类”(Industry Category)，以及“报告时区” (Reporting Time Zone)等信息。 点击”创建“(Create)按钮完成资产创建。 在”追踪代码“(Tracking Code)界面上找到”Tracking ID”的值，例如”UA-12345678-0”. 将其填写到主题配置的plugins &gt; google_analytics &gt; tracking_id即可开启Google Analytics插件。 _config.icarus.yml123plugins: google_analytics: tracking_id: UA-12345678-0 Hotjar安装指南 登录Hotjar，点击页面左上角的➕(加号) &gt; ”添加新站点“(Add new site)链接。 填写”网站地址“(WEBSITE)，”站点类型“(SITE TYPE)，和”站点所有者“(SITE OWNER)，然后点击”添加站点“(Add Site)按钮。 在重定向到的”站点&amp;组织“(Sites &amp; Organizations)页面找到新建的站点。 点击右侧的”追踪代码“(Tracking Code)按钮。 复制弹出对话框中”Site ID”的值(如”1234567”)到主题配置的plugins &gt; hotjar &gt; site_id来启用Hotjar插件。 _config.icarus.yml123plugins: hotjar: site_id: 1234567 Statcounter安装指南 登录Statcounter。 点击“项目”(Projects)页面上的“添加新项目”(Add New Project)。 在“添加页面”(Add Project)页面上填写网站网址和项目标题。 如有需要，调整其他的项目设置。 然后，点击“添加项目”(Add Project)按钮。 点击“完成平台检查”(Platform Check Complete)页面上的“继续默认安装”(Continue to Default Installation)按钮。 最终，在“在你的网站上插入代码”(Insert the Code on Your Website)页面，分别复制HTML代码片段中sc_project和sc_security变量的值 到主题配置中的plugins &gt; statcounter &gt; project和plugins &gt; statcounter &gt; security中。 例如，下面的Statcounter代码： Statcounter code12345678910&lt;script type=&quot;text/javascript&quot;&gt;var sc_project=12345678; var sc_invisible=1; var sc_security=&quot;abcdef12&quot;; var sc_https=1; &lt;/script&gt;&lt;script type=&quot;text/javascript&quot;src=&quot;https://www.statcounter.com/counter/counter.js&quot;async&gt;&lt;/script&gt;... 对应的主题配置为： _config.icarus.yml1234plugins: statcounter: project: 12345678 security: abcdef12 Twitter转化跟踪安装指南 按照如何设置转化跟踪启用Twitter转化追踪的通用网站标签(Universal website tag)。 在你的转化追踪代码中找到init (Pixel ID)。复制它的值到主题配置中的plugins &gt; twitter_conversion_tracking &gt; pixel_id。 例如，如下的Twitter追踪转化代码： Twitter追踪转化代码1234567891011&lt;!-- Twitter universal website tag code --&gt;&lt;script&gt;!function(e,n,u,a){e.twq||(a=e.twq=function(){a.exe?a.exe.apply(a,arguments):a.queue.push(arguments);},a.version='1',a.queue=[],t=n.createElement(u),t.async=!0,t.src='//static.ads-twitter.com/uwt.js',s=n.getElementsByTagName(u)[0],s.parentNode.insertBefore(t,s))}(window,document,'script');// Insert Twitter Pixel ID and Standard Event data belowtwq('init','abcdef');twq('track','PageView');&lt;/script&gt;&lt;!-- End Twitter universal website tag code --&gt; 对应的主题配置为： _config.icarus.yml123plugins: twitter_conversion_tracking: pixel_id: abcdef 文章内容有误？请点击此处提交修改。","link":"/Plugins/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E7%BD%91%E7%AB%99%E5%88%86%E6%9E%90%E6%8F%92%E4%BB%B6/"},{"title":"Icarus 用户指南｜常见问题","text":"本文解答了一些Icarus常见问题。 如果你的问题没有在这里得到解答，也请阅读 Icarus用户指南， Hexo中文文档， 以及GitHub Issues。 此外，你也可以在GitHub讨论组上向其他Icarus用户请求帮助。 站点 我无法生成我的站点。 / 我在生成站点时遇到错误。 Icarus 5运行在Node.js 12.4.0或更新的版本上。 它同时依赖Hexo 6.0.0或更高版本。 除此之外，请确保所有的Node.js依赖已安装。 你可以在&lt;icarus_directory&gt;/package.json 文件的dependencies部分下找到这些依赖。 同时，从你的站点中移除所有无用的Node.js依赖，否则它们可能会导致Icarus出现奇怪的问题。 如何更改我的站点的语言？ 打开站点根目录下的站点配置文件_config.yml，修改如下设置： _config.yml12- language: en+ language: &lt;语言名&gt; 你可以在&lt;icarus_directory&gt;/languages目录下找到所有可用的翻译。 &lt;语言名&gt;为不带后缀名的翻译文件名。 布局 我如何改变页面的宽度？我如何使用单栏/双栏/三栏布局？ 如要改变页面的宽度，编辑&lt;icarus_directory&gt;/include/style/responsive.styl这个样式文件。 此文件定义了不同屏幕尺寸下的页面容器宽度。 如要改变挂件或主内容宽度，编辑&lt;icarus_directory&gt;/layout/common/widgets.jsx和&lt;icarus_directory&gt;/layout/layout.jsx。 在这些文件中找到诸如is-12，is-8-tablet，和is-4-widescreen这样的CSS类名。 CSS类名中的数字标志着一个挂件或主内容所占据的栏数量。 数字后的屏幕尺寸，如tablet和widescreen，指代着栏数量生效的屏幕尺寸条件。 修改类名中的数字使主内容栏的栏数量和所有挂件栏的栏数量在相同屏幕尺寸下相加等于12。 例如，为使主内容栏在宽屏(widescreen)下更宽，你可以做出如下修改： &lt;icarus_directory&gt;/layout/layout.jsx >folded12345678 &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 &lt;icarus_directory&gt;/layout/common/widgets.jsx >folded1234567 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; 你可以参考Bulma文档来获取更多关于布局系统的细节。 下面时一些创建单栏/双栏/三栏布局的提示： 你可以从主题配置中移除所有的挂件来创建单栏布局。 你可以将所有的挂件移动到页面的一侧来创建双栏布局。 你可以将挂件放在页面两边来创建三栏布局。 若要更改单个文章或页面的布局，请参考配置文件与优先级。 挂件/评论插件/分享按钮...的布局文件在哪里？我如何个性化内置的挂件/评论插件/分享按钮...？ 插件和挂件的布局文件已被移至一个单独的Node.js库中——hexo-component-inferno。 这样，主题开发者可以更好地在不同主题之间复用这些通用组件，并且普通用户可以更简便地覆盖这些内置组件。 若要自定义这些组件，从hexo-component-inferno仓库中拷贝布局文件并把它们放入&lt;icarus_directory&gt;/layout下的的相应目录中。 例如，如果你想要自定义Valine评论插件，你可以从hexo-component-inferno仓库中拷贝 src/view/comment/valine.jsx 到&lt;icarus_directory&gt;/layout/comment/valine.jsx。 同时像下面这样改正此文件头部的一些Node.js引用： &lt;icarus_directory&gt;/layout/comment/valine.jsx12- const { cacheComponent } = require('../../util/cache');+ const { cacheComponent } = require('hexo-component-inferno/lib/util/cache'); 最后，用hexo clean清理你的站点并重新生成HTML文件。 类似的，你可以用同样的方式覆盖主题内置的静态文件，如 asset/js/insight.js 。 为什么我的改变的布局文件在我刷新页面时没有生效（假设我正在使用hexo server）？ 当你使用hexo server启动本地Hexo服务器时，Icarus会缓存布局文件。 如要使布局文件的修改生效，请重启本地服务器。 其他情况下临时生成的数据会被Hexo缓存在内存或者db.json数据库中。 在运行hexo server或hexo generate之前执行hexo clean应该可以解决此问题。 内容 我的图片没有正确显示。 / 我的图片仅在首页显示，却无法在文章页面显示。 请确保你使用了图片的绝对路径。 例如，你的站点位于你域名的子目录下，如https://ppoffice.github.io/hexo-theme-icarus， 并且你的图片image.jpg放在了source/gallery/目录下。 那么你应该用/hexo-theme-icarus/gallery/image.jpg来引用你的图片。 你也可以像下面这样使用{% img %}这个Hexo标签来自动引用图片： 1{% img /gallery/image.jpg &quot;Image title&quot; %} 在这种情况下，你可以从图片路径中省略网站子目录。 你可以参考Hexo文档来了解更多详情。 如何为文章添加摘要？如何显示“阅读更多”按钮？ 在你的文章中添加&lt;!-- more --&gt;标签。 标签前面的文章内容会被标记为摘要，而其后的内容不会显示在文章列表上。 你也可以在文章的front-matter中设置自定义摘要。 some-post.md12345title: 一篇文章date: 2020-01-01excerpt: 这是一篇关于...---# 文章内容... 我如何加密文章？ 使用如hexo-blog-encrypt这样的第三方的Hexo插件。 我如何像这篇文章一样使用炫酷的页面元素？ 请参考Bulma文档来了解所有可选的元素和样式。 复制其中的HTML代码段并直接放入你的Markdown文件中。 挂件与插件 我如何才能移除页面上警告我一些配置值没有设置的红色警示信息？ 这些警示信息通常在你遗漏一些插件或挂件的配置设置时出现。 如果你不想开启某个插件或挂件，把它们从你的主题配置中删掉或注释掉。 例如，注释掉这几行来禁用掉评论插件： _config.icarus.yml123456- comment:- type: disqus- shortname: + # comment:+ # type: disqus+ # shortname: 文章内容有误？请点击此处提交修改。","link":"/Guides/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"title":"Icarus 用户指南｜分享按钮","text":"本文介绍Icarus 5支持的分享按钮的安装配置。 下面的分享按钮由ppoffice/hexo-component-inferno提供，完整的支持按钮列表和配置详情以其为准。 .content ol:not([type]) { list-style-type: simp-chinese-informal; } AddThis 此分享按钮可能会被部分广告拦截浏览器扩展拦截，请酌情使用。 AddThis分享按钮服务已下线，建议使用其他分享按钮服务作为替代。 安装指南 在线预览 注册AddThis。 在提交注册表单后的“选择工具”(Select a Tool)页面选择“分享按钮”(Share Buttons)。 在“选择工具类型”(Select a Tool Type)界面选择样式和按钮，点击“继续”(Continue)。 在下一页面中进一步自定义分享按钮，完成时点击“激活工具”(Activate Tool)按钮。 在”获取代码“(Get The Code)页面找到HTML代码，复制src属性值中的URL地址并填入分享按钮配置中。 例如，下面AddThis代码中的URL： AddThis代码12&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-xxxxxxxxxxxxx&quot;&gt;&lt;/script&gt; 对应如下的主题配置： _config.icarus.yml123share: type: addthis install_url: //s7.addthis.com/js/300/addthis_widget.js#pubid=ra-xxxxxxxxxxxxx AddToAny 安装指南 在线预览 你可以启用AddToAny而无需注册用户。 仅需将下面的代码放到你的主题配置中： _config.icarus.yml12share: type: addtoany 如果你想自定义分享按钮，请采用如下步骤： 访问AddToAny官网并点击“获取分享按钮”(Get the Share Button)。 然后，选择“任意网站”(Any Website)并完成按钮的配置。 完成后点击“获取按钮代码”(Get Button Code)。 由于分享按钮是由ppoffice/hexo-component-inferno 提供，你需要将AddToAny的布局文件src/view/share/addtoany.jsx从这个仓库中复制到&lt;icarus_directory&gt;/layout/share/addtoany.jsx。 然后，替换addtoany.jsx中AddToAny代码并修正文件头部的包引用。 例如，假设下面的代码是你从上一步获得的代码： AddToAny代码 >folded123456789&lt;!-- AddToAny BEGIN --&gt;&lt;div class=&quot;a2a_kit a2a_kit_size_32 a2a_default_style&quot;&gt;&lt;a class=&quot;a2a_dd&quot; href=&quot;https://www.addtoany.com/share&quot;&gt;&lt;/a&gt;&lt;a class=&quot;a2a_button_facebook&quot;&gt;&lt;/a&gt;&lt;a class=&quot;a2a_button_twitter&quot;&gt;&lt;/a&gt;&lt;a class=&quot;a2a_button_email&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;script async src=&quot;https://static.addtoany.com/menu/page.js&quot;&gt;&lt;/script&gt;&lt;!-- AddToAny END --&gt; 那么你需要对addtoany.jsx做出如下修改： &lt;icarus_directory&gt;/layout/share/addtoany.jsx >folded123456789101112131415161718192021222324const { Component, Fragment } = require('inferno');- const { cacheComponent } = require('../../util/cache');+ const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');...中间省略部分代码...class AddToAny extends Component { render() { return &lt;Fragment&gt;- &lt;div class=&quot;a2a_kit a2a_kit_size_32 a2a_default_style&quot;&gt;- &lt;a class=&quot;a2a_dd&quot; href=&quot;https://www.addtoany.com/share&quot;&gt;&lt;/a&gt;- &lt;a class=&quot;a2a_button_facebook&quot;&gt;&lt;/a&gt;- &lt;a class=&quot;a2a_button_twitter&quot;&gt;&lt;/a&gt;- &lt;a class=&quot;a2a_button_telegram&quot;&gt;&lt;/a&gt;- &lt;a class=&quot;a2a_button_whatsapp&quot;&gt;&lt;/a&gt;- &lt;a class=&quot;a2a_button_reddit&quot;&gt;&lt;/a&gt;- &lt;/div&gt;+ 刚刚获取的AddToAny HTML代码替换到这里 &lt;script src=&quot;https://static.addtoany.com/menu/page.js&quot; defer={true}&gt;&lt;/script&gt; &lt;/Fragment&gt;; }}...下面省略部分代码... 百度分享 此分享按钮可能会被部分广告拦截浏览器扩展拦截，请酌情使用。 百度分享按钮服务似乎已下线，建议使用其他分享按钮服务作为替代。 安装指南 你可以启用百度分享按钮而无需注册用户。 直接将下面的代码添加到你的主题配置中： _config.icarus.yml12share: type: bdshare Share.js Share.js服务已停止维护，建议使用其他分享按钮服务作为替代。 安装指南 在线预览 你可以启用Share.js分享按钮而无需用户注册。 直接将下面代码添加到主题配置中： _config.icarus.yml12share: type: sharejs (可选)请参照AddToAny部分的个性化步骤与share.js主页 来了解更多关于自定义分享按钮的信息。 ShareThis 安装指南 在线预览 访问ShareThis并点击页面上的“从分享按钮开始”(Start with Share Buttons)按钮。 在“选择分享按钮类型”(Choose type of sharing button)页面选择你需要的按钮类型。 不要启用”GDPR规范工具“，否则可能会导致一些问题。 你也可以点击“自定义你的分享按钮”(Customize your share buttons)链接来进行按钮的进一步配置。 完成后点击“下一步”(Next)。 在”选择你的CMS平台“(Choose your CMS platform)页面选择”HTML“并点击”下一步“(Next)。 在“注册并获取代码”(Register and get the code!)页面输入邮箱和密码完成ShareThis的注册。 最后，从HTML代码段中复制src中的URL地址到分享按钮配置中。 例如，下面的ShareThis代码： AddThis代码1&lt;script type=&quot;text/javascript&quot; src=&quot;https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 对应下面的主题配置： _config.icarus.yml123share: type: sharethis install_url: https://platform-api.sharethis.com/js/sharethis.js#property=xxxxxxxxxxxxx&amp;product=inline-share-buttons 文章内容有误？请点击此处提交修改。","link":"/Plugins/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E5%88%86%E4%BA%AB%E6%8C%89%E9%92%AE/"},{"title":"Icarus 用户指南｜挂件","text":"本文介绍Icarus 5支持的页面挂件的安装配置。 若要同时展示多个挂件，只需在主题配置的widgets数组中添加多个挂件配置。 它们会按照定义的顺序出现。 每个挂件必须包含type(挂件类型)与position(挂件展示位置)设置项。 示例如下： _config.icarus.yml123456789widgets: - type: ... # 挂件1 position: left ... - type: ... # 挂件2 position: right ... 下面的挂件由ppoffice/hexo-component-inferno提供，完整的支持挂件列表和配置详情以其为准。 作者资料卡你可以启用作者资料卡挂件来展示文章作者/网站站长的信息。 资料卡的配置如下所示： _config.icarus.yml123456789101112131415161718192021222324widgets: - position: right type: profile # 作者名称 author: hulatocat # 作者头衔 author_title: A GitHub Octocat # 作者所在地/公司 location: GitHub Inc. # 头像图片地址 avatar: https://octodex.github.com/images/hula_loop_octodex03.gif # 是否显示圆形头像 avatar_rounded: false # Gravatar邮箱(如不设置`avatar`项) gravatar: # 关注按钮链接地址 follow_link: 'https://octodex.github.com/hulatocat' # 社交媒体链接 social_links: Github: icon: fab fa-github url: 'https://github.com/' Icarus: 'https://github.com/ppoffice/hexo-theme-icarus' 需要注意的是： 如果你希望使用Gravatar而不是avatar配置项作为头像图片，请在gravatar项填入 你的Gravatar邮箱地址并在avatar一项中留空； social_links可以采用如下两种格式： 图标形式： social_links123&lt;链接名称&gt;: icon: &lt;FontAwesome5_图标的_HTML_class名称&gt; url: &lt;链接的URL地址&gt; 文字形式： social_links1&lt;链接名称&gt;: &lt;链接的URL地址&gt; 文章目录若要展示文章目录，请在主题配置中添加如下挂件配置： _config.icarus.yml123456widgets: - type: toc position: left # 是否显示目录项目的序号 index: true 然后，在需要开启目录的文章头部加入toc: true： Post.md1234title: 一篇有目录的文章toc: true---文章内容... 友站链接你可以使用友站链接挂件来展示外部网站的列表。 示例配置如下所示： _config.icarus.yml12345678widgets: - position: left type: links # 友站名称与链接 links: Hexo: 'https://hexo.io' Bulma: 'https://bulma.io' 最新文章使用如下挂件配置来开启最新文章挂件： _config.icarus.yml1234widgets: - position: right type: recent_posts 文章归档使用如下挂件配置来开启文章归档挂件： _config.icarus.yml1234widgets: - position: right type: archives 文章分类使用如下挂件配置来开启文章分类挂件： _config.icarus.yml1234widgets: - position: right type: categories 文章标签使用如下挂件配置来开启文章标签挂件： _config.icarus.yml1234567widgets: - position: right type: tags order_by: name # 可选项。按名称(name)或长度(length)来排序。加上`-`前缀来倒序排列。 amount: 20 # 可选项。最多显示的标签数量。留空以显示所有标签。 show_count: true # 可选项。是否显示标签名称右侧的文章数量。 Google Feedburner Google即将关闭Feedburner的邮件订阅功能。 你可以切换到follow.it挂件或者其他邮件订阅服务。 按照如下步骤即可启用Google Feedburner插件： 首先，使用诸如hexo-generator-feed此类的Hexo插件生成 你的Hexo网站的RSS源。 然后登录Google Feedburner，在输入框内输入你的RSS地址并点击“下一步”(Next) 来添加你的RSS源。 然后，在下一页中填写“源标题”。 点击“下一步”(Next)来继续自定义你的源，或者点击“直接跳到源管理”(Skip directly to feed management)来完成配置。 完成添加源后，点击网页顶部的”我的源“(My Feeds)链接。 点击“我的源”(My Feeds)页面上新添加的源。 切换到”宣传“(Publicize)标签页并点击页面左侧的”邮件订阅“(Email Subscription)链接。 点击“激活”(Activate)按钮来开启“邮件订阅”(Email Subscription)功能。 在”邮件订阅“(Email Subscription)页面上从HTML代码中找到如下信息： Google Feedburner URL1https://feedburner.google.com/fb/a/mailverify?uri=****** 复制uri=后的ID(如feedforall/ABCD)到挂件配置的feedburner_id设置中： _config.icarus.yml1234567widgets: - position: left type: subscribe_email # (可选) 描述文字 description: 邮件订阅，更新早知道 feedburner_id: feedforall/ABCD Google AdSense在Google AdSense上新建广告。 然后，复制广告HTML代码中的data-ad-client和data-ad-slot值分别填入到挂件配置的client_id和slot_id项中。 示例如下： _config.icarus.yml123456widgets: - position: left type: adsense client_id: ca-pub-xxxxxxxx slot_id: xxxxxxx follow.it按照如下步骤即可启用follow.it邮件订阅插件： 首先，使用诸如hexo-generator-feed此类的Hexo插件生成 你的Hexo网站的RSS源。 访问follow.it并在“向你的站点添加关注功能”(Add the follow feature to your site)下方的 输入框中填写RSS源的文件地址，例如http://example.com/atom.xml。 然后，点击“下一步”(Next)。 点击“定义关注表单设计”(Define the follow form’s design)页面上的“继续”(Continue)按钮。 搜索action=并复制action=后双引号中的链接。 把你复制的action链接粘贴到挂件配置中的action_url设置项。 在那之后，点击“完成”(Done)。 _config.icarus.yml1234567widgets: - position: left type: followit description: action_url: https://api.follow.it/****** verification_code: '' 点击“继续”(Continue)按钮或者“跳过此步”(Skip this)链接来跳过“选择你想要的关注按钮”(Pick the Follow icons you want)和 ”显示弹窗来最大化交流“(Show a pop-up for maximum conversion)页面。 在”连接你的源到follow.it账户“(Connect your feed to a follow.it account)页面上，在输入框中填入你将要用来注册follow.it账户 和管理订阅者的邮箱地址。 然后，点击”开始“(Start)。 你会收到一封来自follow.it的邮件。 在那封邮件中搜索&lt;meta name=&quot;follow_it-verification-code&quot; content=&quot;******&quot;/&gt;并复制content=后双引号中的content的值。 将你复制的值粘贴到挂件设置中的verification_code设置项。 _config.icarus.yml1234567widgets: - position: left type: followit description: action_url: https://api.follow.it/****** verification_code: ****** 生成你的站点并将其上传到你的服务器。 回到follow.it并用你的邮箱地址注册一个账户。 回到你收到的第一封邮件并点击”点击这里来认领“(Click here to claim it)链接来认领你的订阅源。 文章内容有误？请点击此处提交修改。","link":"/Widgets/icarus-%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BD%9C%E6%8C%82%E4%BB%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"sort()","slug":"sort","link":"/tags/sort/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"二叉搜索树","slug":"二叉搜索树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"Hierholzer 算法","slug":"Hierholzer-算法","link":"/tags/Hierholzer-%E7%AE%97%E6%B3%95/"},{"name":"欧拉路径","slug":"欧拉路径","link":"/tags/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/"},{"name":"类","slug":"类","link":"/tags/%E7%B1%BB/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"哈希碰撞","slug":"哈希碰撞","link":"/tags/%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"}],"categories":[{"name":"Guides","slug":"Guides","link":"/categories/Guides/"},{"name":"代码心得","slug":"代码心得","link":"/categories/%E4%BB%A3%E7%A0%81%E5%BF%83%E5%BE%97/"},{"name":"算法随想录","slug":"算法随想录","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"回溯算法","slug":"算法随想录/回溯算法","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"name":"栈与队列","slug":"算法随想录/栈与队列","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"二叉树","slug":"算法随想录/二叉树","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"算法随想录/链表","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"算法随想录/数组","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"算法随想录/哈希表","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"贪心算法","slug":"算法随想录/贪心算法","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法随想录/字符串","link":"/categories/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Plugins","slug":"Plugins","link":"/categories/Plugins/"},{"name":"Widgets","slug":"Widgets","link":"/categories/Widgets/"}],"pages":[{"title":"","text":"一个为 Hexo 静态网站生成器打造的简洁、精致、现代的主题。 预览 | 文档 | GitHub 讨论区 :cd: 安装$ npm install hexo-theme-icarus $ hexo config theme icarus 详细安装说明请参考：Icarus 入门指南 :gift: 特性亮点赛博朋克主题风格全新加入的赛博朋克主题变体，带你进入未来的网络世界。 灵感来源于 Cyberpunk 2077。 丰富的插件支持Icarus 内置多种搜索、评论、分享等插件，让你的博客功能更强大、更丰富。 评论系统 畅言 · Disqus · DisqusJS · Facebook · Gitalk · Gitment · Isso · 来必力 LiveRe · Utterance · Valine 打赏按钮 爱发电 · 支付宝 · Buy me a coffee · Patreon · PayPal · 微信 搜索功能 Algolia · 百度 · Google 自定义搜索 · Insight 分享功能 AddThis · AddToAny · 百度分享 · Share.js · ShareThis 小部件 谷歌广告 · 文章归档 · 分类目录 · 外部链接 · 最近文章 · Google Feedburner · 标签 · 目录导航 网站统计 百度统计 · 必应站长工具 · 不蒜子 · CNZZ 统计 · Google Analytics · Hotjar · StatCounter · Twitter 转化追踪 其他插件 Cookie 提示 · LightGallery 图库 · Justified Gallery · KaTeX · MathJax 数学公式 · 旧浏览器提示 · 页面加载动画 多彩代码高亮主题Icarus 直接引入了 highlight.js 提供的样式，可选择超过 90 种代码高亮主题。 Atom One Light Monokai Kimbie Dark 灵活的主题配置方式Icarus 支持按页面、按布局分别设置主题配置。 _config.icarus.yml12345widgets: - type: profile position: left - type: recent_posts position: right post.md12345widgets: - type: profile position: left - type: recent_posts position: left _config.page.yml1widgets: null 响应式布局设计Icarus 拥有移动端友好的响应式布局，带来更佳的阅读体验。 :hammer: 开发信息本项目基于以下技术构建： Hexo Inferno.js Stylus Bulma 请参考 官方文档 和 贡献指南 获取更多开发细节。 :tada: 贡献指南如果你愿意帮助我们打造更好的 Icarus，你可以： :black_nib: 提交一篇教程 | :earth_asia: 添加一项翻译 | :triangular_flag_on_post: 报告一个 Bug | :electric_plug: 建议一个新功能 :memo: 许可证本项目基于 MIT 协议开源。详情请见 LICENSE 文件。","link":"/about/index.html"}]}